# RPG rebel game
    # Import pygame and random
import pygame, sys
from pygame.locals import *
from collections import deque
import random



SONG_FINISHED = pygame.USEREVENT + 1


    # Constants for colours
FUCHSIA = ( 255, 0, 255 )

    # Holds FPS
FPS = 30




    # Attack menus
ATTACK_ENCOUNTER = 0
ATTACK_MENU = 1
ABILITY_MENU = 2
ITEM_MENU = 3
ACTION_MENU = 4






    # Constant for animation numbers
IDLE = 0
ATTACK_ONE = 1
ATTACK_TWO = 2

    # The length and speed of each animation
AnimLength = [ 2, 5 ]
AnimSpeed = [ 20, 1 ]

    # Constants for attack types
BASIC = 0
BLEEDING = 1
POISON = 2
FIRE = 3
DOUBLE = 4
HEAL = 5
STUN = 6
BARRAGE = 7
CURSE = 8

    # All of the monster's stats
PIG = 0
WILD_DOG = 1
THIEF = 2

# NAME, HEALTH per level, DAMAGE per level, ATTACK_1, attackDamage, attackType, attacksound, ATTACK_2, attackDamage, attackType, attacksound, DEFENCE, SPEED
MonsterStats = [
[ "Pig",        2,  0.1, "headbut",         1,   BASIC, "zapsplat_animals_pig_grunt_snort_002_17838.wav",               "eat garbage", 5,   HEAL,   "zapsplat_animals_pig_grunt_snort_002_17838.wav",   0.1, 0.1  ],
#[ "Wild Dog",   3,  0.2, "bite",            1.2, BLEEDING,    "bite",        1.2, BASIC,  0.1, 0.4  ],
[ "Thief",      3,  0.1, "punch",           2,   BASIC, "zapsplat_water_soapy_foam_splat_hit_001.wav",                  "poison dart", 1,   POISON, "zapsplat_water_soapy_foam_splat_hit_001.wav", 0,   0.2  ],
#[ "Golem",      15, 0.1, "punch",           1,   BASIC,    "trample",     3,   BASIC,  0.5, 0.05 ],
#[ "Knight",     10, 0.3, "slash",           3,   BLEEDING, "double slash",2,   DOUBLE, 0.3, 0.2  ],
[ "Demon",      20, 0.5, "curse",           2,   CURSE,     "", "flame",       3,   FIRE,   0.2, 0.3  ],
[ "King",       30, 0.2, "sword barrage",   1,   BARRAGE,   "zapsplat_warfare_sword_swipe_body_hit_slash_20827.wav",    "shockwave",   3,   STUN,   "zapsplat_warfare_sword_swipe_body_hit_slash_20827.wav",   0.4, 0.5  ]
]

    # All the of the monster's animations

ATTACK_1 = 1
ATTACK_2 = 2

MonsterAnimLength = [
[ 2, 3, 2  ],
#[ 2, 3, 2  ],
[ 2, 3, 5  ],
#[ 2, 3, 2  ],
#[ 2, 3, 2  ],
[ 2, 3, 2  ],
[ 2, 3, 11 ]
]
MonsterAnimSpeed  = [
[ 20, 5, 5 ],
#[ 20, 5, 5 ],
[ 20, 5, 5 ],
#[ 20, 5, 5 ],
#[ 20, 5, 5 ],
[],
[ 20, 8, 2 ]
]






























Items = [
    #       +  Attack items
"Mushroom",
"Red paint",
"\"Introduction to stabbing\" textbook",
"Angry sticker",
"Skull tattoo",

    #       ++ Attack items
"Sharpening stone",
"Clawed gloves",
"Fire flower",
"Extra blade",
"Rusty sidearm",

    #       +  Defence items
"Beanie",
"Pillow",
"Facemask",
"Silk scarf",
"Goggles",

    #       ++ Defence items
"Hard hat",
"Shoulder guards",
"Police vest",
"A PG 13+ rating",
"Mouthguard",

    #       +  Speed items
"Anime hair",
"Shoelaces",
"Paranoia",
"Tennis shoes",
"Blue paint",

    #       ++ Speed items
"Flaming pants",
"Grease",
"Hoverboard",
"Bees knees",
"Wings",

    #       -  Store cost items
"Painted eyebrows",
"Loud voice",
"Bow tie",
"Extra makeup",
"Googley eyes",

    #       -- Store cost items
"Spiked collar",
"Painfully large smile",
"Nice suit",
"Tight money pouch",
"\"How to real-estate\" textbook"
]
























    # The game maps
TUTORIAL_LEVEL = [
    3, 1,
    0, 1,
    2, 1,
    0, 1,
    0, 0,
    3, 0,
    0, 0,
    0, 1,
    0, 1,
    0, 1,
    0, 1,
    0, 1,
    0, 1
    ]

"""
0 = Plains
1 = Forrest
2 = Sand
3 = Shallow Water
4 = Med Water
5 = Deep Water
6 = Low Mountain
7 = Med Mountain
8 = High Mountain
9 = Cave entrance ( Up )
10 = Cave entrance ( Mid )
11 = Cave entrance ( Down )
12 = shop 1
13 = shop 2
14 = shop 3
15 = Village 1
16 = Village 2
17 = Village 3
18 = Castle walls ( horizontal )
19 = Castle walls ( vertical )
20 = Castle walls ( corner |_ )
21 = Castle walls ( corner _| )
22 = Castle top
23 = Castle entrance ( Left )
24 = Castle entrance ( Mid )
25 = Castle entrance ( Right )
26 = Bridge Walls
27 = Bridge Floor
"""

MAIN_MAP_1 = [
    5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 0, 0, 0, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 0, 0, 0, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    5, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 0, 0, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    4, 5, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 0, 0, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    3, 4, 5, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 0, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    2, 3, 4, 4, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 0, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    2, 2, 3, 3, 4, 4, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 0, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    2, 2, 2, 2, 3, 3, 4, 5, 5, 5, 5, 4, 3, 3, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 1, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    2, 2, 2, 2, 2, 2, 3, 4, 4, 5, 5, 5, 4, 4, 3, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 1, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    0, 0, 2, 2, 2, 2, 2, 3, 3, 4, 5, 5, 5, 5, 4, 3, 3, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 1, 1, 1, 1, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    0, 0, 0, 2, 2, 2, 2, 2, 2, 3, 4, 5, 5, 5, 5, 4, 4, 3, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 1, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5, 4, 3, 3, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 1, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5, 4, 4, 3, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 1, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 1, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 4, 3, 3, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 1, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 4, 4, 3, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 0, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 0, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 0, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 0, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 0, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 2, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 0, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 0, 0, 0, 0, 3, 4, 5, 4, 3, 0, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 0, 0, 0, 0, 3, 4, 5, 4, 3, 0, 20, 18, 18, 18, 18, 18, 18, 18, 23, 24, 25, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 21,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 0, 0, 0, 0, 3, 4, 5, 4, 3, 0, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1 , 1, 1, 1, 0, 0, 0, 0, 3, 4, 5, 4, 3, 3, 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1 , 1, 1, 1, 1, 0, 0, 0, 3, 4, 5, 4, 4, 4, 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 , 1, 1, 1, 1, 0, 0, 0, 3, 4, 5, 5, 5, 5, 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 15,0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 3, 3, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 1, 1, 1, 0, 0, 0, 0, 3, 4, 4, 4, 4, 4, 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 3, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 1, 1, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 4, 3, 3, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 5, 5, 4, 4, 3, 3, 2, 2, 2, 2, 2, 2, 2, 0 , 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 5, 4, 4, 3, 3, 2, 2, 2, 2, 2, 2 , 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 4, 4, 3, 2, 2, 2, 2, 2 , 2, 2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 5, 5, 5, 5, 5, 5, 4, 3, 3, 2, 2, 2 , 2, 2, 2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4, 4, 5, 5, 5, 5, 5, 4, 4, 3, 3, 2 , 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 1, 1, 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 5, 5, 5, 5, 5, 5, 4, 4, 3 , 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 1, 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4, 4, 5, 5, 5, 5, 5, 5, 4 , 3, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1, 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 5, 5, 5, 5, 5, 5 , 4, 3, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5 , 5, 4, 3, 3, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 3, 4, 5, 5, 5, 5 , 5, 5, 4, 4, 3, 2, 2, 2, 2, 2, 2, 0, 0, 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 3, 4, 5, 5, 5 , 5, 5, 5, 4, 3, 2, 2, 2, 2, 2, 2, 2, 0, 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 3, 4, 4, 5 , 5, 5, 5, 5, 4, 3, 3, 2, 2, 2, 2, 2, 0, 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 3, 3, 4 , 4, 5, 4, 4, 5, 4, 4, 3, 2, 2, 2, 2, 2, 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 3 , 3, 4, 6, 6, 4, 5, 4, 3, 2, 2, 2, 2, 2, 2 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2 , 2, 6, 6, 6, 4, 5, 5, 4, 3, 2, 2, 2, 2, 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2 , 6, 6, 7, 7, 6, 4, 5, 5, 4, 3, 3, 2, 2, 2 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 6 , 6, 7, 7, 7, 6, 4,17, 5, 5, 4, 4, 3, 2, 2 , 2 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6 , 7, 7, 8, 7, 7, 6, 4, 5, 5, 5, 5, 4, 3, 3 , 2 , 2 , 2 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7 , 7, 8, 8, 8, 7, 7, 6, 4, 4, 5, 5, 5, 4, 4 , 3 , 2 , 2 , 2 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7 , 7, 8, 8, 8, 8, 7, 7, 6, 3, 4, 5, 5, 5, 5 , 4 , 3 , 3 , 2 , 2 , 2 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 7 , 7, 8, 8, 8, 8, 8, 7, 6, 2, 3, 4, 5, 5, 5 , 5 , 4 , 4 , 3 , 3 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 2 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7 , 8, 8, 8, 8, 8, 8, 7, 7, 6, 2, 3, 4, 5, 5 , 5 , 5 , 5 , 4 , 4 , 3 , 3 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 26, 27, 27, 26, 0 , 0 , 0 , 2 , 2 , 2 , 2 , 2 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7 , 8, 8, 8, 8, 8, 8, 7, 7, 6, 2, 2, 3, 4, 4 , 5 , 5 , 5 , 5 , 5 , 4 , 4 , 3 , 3 , 3 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 26, 27, 27, 26, 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7 , 8, 8, 8, 8, 8, 8, 7, 7, 7, 6, 2, 2, 3, 3 , 4 , 4 , 5 , 5 , 5 , 5 , 5 , 4 , 4 , 4 , 3 , 3 , 3 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 26, 27, 27, 26, 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7 , 8, 8, 8, 8, 8, 8, 8, 7, 7, 6, 2, 2, 2, 2 , 3 , 3 , 4 , 4 , 5 , 5 , 5 , 5 , 5 , 5 , 4 , 4 , 4 , 3 , 3 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 26, 27, 27, 26, 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7 , 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 6, 2, 2, 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 5 , 5 , 4 , 4 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 26, 27, 27, 26, 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7 , 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 6, 2, 2, 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 5 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 26, 27, 27, 26, 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7 , 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 6, 2, 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 26, 27, 27, 26, 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7 , 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 6, 0, 0 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 26, 27, 27, 26, 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7 , 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 6, 0 , 0 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 26, 27, 27, 26, 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7 , 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 6 , 0 , 0 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 26, 27, 27, 26, 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , # Line 62
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7 , 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7 , 6 , 0 , 0 , 0 , 0 , 0 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 26, 27, 27, 26, 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7 , 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 26, 27, 27, 26, 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7 , 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7 , 7 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 26, 27, 27, 26, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7 , 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7 , 7 , 6 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 26, 27, 27, 26, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7 , 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 7 , 7 , 6 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 26, 27, 27, 26, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 7 , 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 7 , 7 , 6 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7 , 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 7 , 7 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7 , 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 7 , 6 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7 , 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 7 , 7 , 7 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7 , 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7 , 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6 , 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9 , 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6 , 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6 , 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6 , 6, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 6, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 6, 6, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 6 , 6 , 6 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 6, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 6 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 6 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 6 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 6 , 6 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 6 , 6 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 6, 6, 6, 7, 7, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 6 , 6 , 6 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 6, 6, 7, 7, 8, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 6 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 6, 6, 7, 7, 8, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 6 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0, 6, 6, 7, 7, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 6 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0 , 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7, 8, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 6 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 , 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7, 8, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7, 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7 , 7 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6 , 7 , 7 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 6 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 6 , 7 , 7 , 7 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 9 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0 , 6 , 7 , 7 , 7 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7 , 7 , 10, 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 , 0 , 0 , 6 , 6 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 11, 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 , 0 , 0 , 0 , 6 , 6 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 6 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
    ]




















    # Boolean variable for if the game is muted or not
Muted = False

    # Scene numbers
MAIN_MENU = 1
OPTIONS_MENU = 2
CHARACTER_CREATION = 3
TUTORIAL = 4
MAIN_MAP = 5
BOSSFIGHT = 6
CONGRATS = 7
CREDITS = 8

    # Button numbers
PLAY_BUTTON = 1
OPTIONS_BUTTON = 2
MUTE_BUTTON = 3

    # Create variables for the screen size
SCREEN_WIDTH = 900
SCREEN_HEIGHT = 600

    # Create variables for the mouse size
MOUSE_SIZE = 50

    # Variable for the pixel size
PIXEL_SIZE = SCREEN_WIDTH / 60

    # Create a screen to paste images on
DISPLAYSURF = pygame.display.set_mode( ( SCREEN_WIDTH, SCREEN_HEIGHT ) )

    # Variable to control the FPS
FPS = 60

    # Player pos constants
BATTLE_X = 100
BATTLE_Y = 200













    # Creates variables for the mouse
MouseIMG = pygame.image.load( "Assets/Mouse/Mouse_1.png" )
MouseIMG = pygame.transform.scale( MouseIMG, ( MOUSE_SIZE, MOUSE_SIZE ) )
MouseX = 0
MouseY = 0







    # Variable for the difficulty
Difficulty = 0


















def LoadBackground( backNo ):
    Back = pygame.image.load( "Assets/Backgrounds/Background_" + str( backNo ) + ".png" )
    return pygame.transform.scale( Back, ( SCREEN_WIDTH, SCREEN_HEIGHT ) )


















    # A data type created for all buttons
class Button:

        # Class constructor initializes member varaibles
    def __init__ ( self, path, x, y, w, h ):

            # Holds the x and y position of the button
        self.x = x
        self.y = y

            # Holds the size of the button
        self.w = w
        self.h = h

            # Holds the scaled image of the button
        self.Image = pygame.image.load( path )
        self.Image = pygame.transform.scale( self.Image, ( w, h ) )



        # Member function that prints the button onto the screen
    def Render( self ):
        DISPLAYSURF.blit( self.Image, ( self.x, self.y, self.w, self.h ) )

        # Returns if the mouse is over the button or not
    def Clicked( self ):
        return not (
            self.x + self.w < pygame.mouse.get_pos()[ 0 ]   or
            self.x > pygame.mouse.get_pos()[ 0 ]            or
            self.y + self.h < pygame.mouse.get_pos()[ 1 ]   or
            self.y > pygame.mouse.get_pos()[ 1 ]
            )

    def SetImage( self, path ):
        self.Image = pygame.image.load( path )
        self.Image = pygame.transform.scale( self.Image, ( self.w, self.h ) )






            # Shows a GAME OVER screen when the player looses
def GameOver():
        # Loads the GAME OVER image
    GAME_OVER = pygame.image.load( "Assets/Backgrounds/GAME_OVER.png" )
    GAME_OVER = pygame.transform.scale( GAME_OVER, ( SCREEN_WIDTH, SCREEN_HEIGHT ) )

        # Blit it to the screen
    DISPLAYSURF.blit( GAME_OVER, ( 0, 0 ) )

        # Update the screen
    pygame.display.update()

        # Wait for the player to quit
    while True:
        for event in pygame.event.get():
            if event.type == QUIT:

                pygame.quit()
                sys.exit()





                # Prints a box that tells the player that they leveled up
def PrintLevelUp():
    Box = pygame.image.load( "Assets/Other/TextBox_1.png" )
    Box = pygame.transform.scale( Box, ( int ( SCREEN_WIDTH / 2 ), int ( SCREEN_HEIGHT / 2 ) ) )

    BigFont = pygame.font.SysFont( "luxirb.ttf", 56 )
    SmallFont = pygame.font.SysFont( "luxirb.ttf", 56 )

    LevelUp = BigFont.render( "YOU LEVELED UP!", True, ( 0, 0, 0 ) )
    Rewards = SmallFont.render( "All skills increased and health restored!", True, ( 0, 0, 0 ) )

    DISPLAYSURF.blit( Box, ( int ( SCREEN_WIDTH / 4 ), int ( SCREEN_HEIGHT / 4 ), int ( SCREEN_WIDTH / 2 ), int ( SCREEN_HEIGHT / 2 ) ) )
    DISPLAYSURF.blit( LevelUp, ( int ( SCREEN_WIDTH / 2 ) - int ( LevelUp.get_rect().size[ 0 ] / 2 ), int ( SCREEN_HEIGHT / 2 ) - LevelUp.get_rect().size[ 1 ] * 2, LevelUp.get_rect().size[ 0 ], LevelUp.get_rect().size[ 1 ] ) )
    DISPLAYSURF.blit( Rewards, ( int ( SCREEN_WIDTH / 2 ) - int ( Rewards.get_rect().size[ 0 ] / 2 ), int ( SCREEN_HEIGHT / 2 ), Rewards.get_rect().size[ 0 ], Rewards.get_rect().size[ 1 ] ) )

    pygame.display.update()

    while True:
        for event in pygame.event.get():
            if event.type == QUIT:

                pygame.quit()
                sys.exit()

            elif event.type == MOUSEBUTTONDOWN:

                return















class Player:

    def __init__ ( self, name, hair, skin, eyes, bandana, shirt, pants, colour, p_Class ):

        self.x = 0
        self.y = 0
        self.w = 0
        self.h = 0

        self.name = name

        self.hair = hair
        self.skin = skin
        self.eyes = eyes
        self.bandana = bandana
        self.shirt = shirt
        self.pants = pants

        self.p_Class = p_Class

        self.Gold = 100
        self.Xp = 0
        self.Level = 1

        self.Items = []

        self.Frame = 0
        self.Timer = 0
        self.CurAnim = -1

        self.MapImage = pygame.image.load( ( "Assets/Character Creation Icons/Colour/Colour_" + str( colour ) + ".png" ) )
        self.MapImage = pygame.transform.scale( self.MapImage, ( 10, 20 ) )

        DISPLAYSURF.blit( self.MapImage, ( 10, 10, 10, 20 ) )

        if p_Class == 1:
            self.strength = 12
            self.speed = 3
            self.wisdom = 6

        elif p_Class == 2:
            self.strength = 3
            self.speed = 12
            self.wisdom = 6

        elif p_Class == 3:
            self.strength = 6
            self.speed = 3
            self.wisdom = 12

        self.health = self.strength * 10
        self.MAX_health = self.strength * 10

        self.attacks   = [ "Basic", None, None, None ]
        self.abilities = [ None, None, None, None ]
        self.actions   = [ "Run", None, None, None ]
        self.Attacked  = False

        self.defence = 0


    def SetPos( self, x, y ):

         self.x = x
         self.y = y

    def SetSize( self, w, h ):

        self.w = w
        self.h = h

    def GainLoot( self, gold, xp ):
        self.Gold += gold
        self.Xp += xp
        if self.Xp >= self.Level * 10:
            PrintLevelUp()

            self.Xp -= self.Level * 10
            self.Level += 1

            self.strength += 2
            self.speed += 2
            self.wisdom += 2

            self.health = self.strength * 10
            self.MAX_health = self.strength * 10

            if self.Level == 3:
                self.actions[ 1 ] = "Defend"
            elif self.Level == 5:
                self.attacks[ 1 ] = "Charge"
            elif self.Level == 10:
                self.attacks[ 2 ] = "Flurry"
            elif self.Level == 20:
                self.actions[ 2 ] = "Prepare"


    def RenderMapCam( self, CamX, CamY ):
        DISPLAYSURF.blit( self.MapImage, ( self.x + 10 - CamX, self.y - CamY, 10, 20 ) )

    def RenderMap( self ):
        DISPLAYSURF.blit( self.MapImage, ( self.x + 10, self.y, 10, 20 ) )

    def Render( self, AnimNum, target = None, attack = None ):

            # Increase the frame if the animation is continued
        if self.CurAnim == AnimNum:
            self.Timer += 1
                # If the timer has reached 50 frames, change animation frame
            if self.Timer >= AnimSpeed[ AnimNum ]:
                if target != None:
                    if self.Frame == 0:
                        if self.HeldFrames > 6:
                            self.Frame += 1
                        else:
                            self.HeldFrames += 1
                    elif self.Frame < AnimLength[ AnimNum ] - 1:
                        self.Frame += 1
                    elif not self.Attacked:
                        self.Attack( attack, target )
                        self.Attacked = True
                else:
                    self.Frame += 1
                        # If the animation frame is past the end of the animation, loop
                    if self.Frame >= AnimLength[ AnimNum ]:
                        self.Frame = 0


                    # Reset the timer
                self.Timer = 0

        else:
            self.CurAnim = AnimNum
            self.Attacked = False
            self.Frame = 0
            self.HeldFrames = 0


        self.HairImg = pygame.image.load( "Assets/Character Encounter/Hair/" + str( AnimNum ) + "/" + str( self.Frame ) + "/Hair_" + str( self.hair ) + ".png" )
        self.HairImg = pygame.transform.scale( self.HairImg, ( int ( self.HairImg.get_rect().size[ 0 ] * PIXEL_SIZE ), int ( self.HairImg.get_rect().size[ 1 ] * PIXEL_SIZE ) ) )

        self.SkinImg = pygame.image.load( "Assets/Character Encounter/Skin/" + str( AnimNum ) + "/" + str( self.Frame ) + "/Skin_" + str( self.skin ) + ".png" )
        self.SkinImg = pygame.transform.scale( self.SkinImg, ( int ( self.SkinImg.get_rect().size[ 0 ] * PIXEL_SIZE ), int ( self.SkinImg.get_rect().size[ 1 ] * PIXEL_SIZE ) ) )

        self.EyesImg = pygame.image.load( "Assets/Character Encounter/Eyes/" + str( AnimNum ) + "/" + str( self.Frame ) + "/Eyes_" + str( self.eyes ) + ".png" )
        self.EyesImg = pygame.transform.scale( self.EyesImg, ( int ( self.EyesImg.get_rect().size[ 0 ] * PIXEL_SIZE ), int ( self.EyesImg.get_rect().size[ 1 ] * PIXEL_SIZE ) ) )

        self.BandanaImg = pygame.image.load( "Assets/Character Encounter/Bandana/" + str( AnimNum ) + "/" + str( self.Frame ) + "/Bandana_" + str( self.bandana ) + ".png" )
        self.BandanaImg = pygame.transform.scale( self.BandanaImg, ( int ( self.BandanaImg.get_rect().size[ 0 ] * PIXEL_SIZE ), int ( self.BandanaImg.get_rect().size[ 1 ] * PIXEL_SIZE ) ) )

        self.ShirtImg = pygame.image.load( "Assets/Character Encounter/Shirt/" + str( AnimNum ) + "/" + str( self.Frame ) + "/Shirt_" + str( self.shirt ) + ".png" )
        self.ShirtImg = pygame.transform.scale( self.ShirtImg, ( int ( self.ShirtImg.get_rect().size[ 0 ] * PIXEL_SIZE ), int ( self.ShirtImg.get_rect().size[ 1 ] * PIXEL_SIZE ) ) )

        self.PantsImg = pygame.image.load( "Assets/Character Encounter/Pants/" + str( AnimNum ) + "/" + str( self.Frame ) + "/Pants_" + str( self.pants ) + ".png" )
        self.PantsImg = pygame.transform.scale( self.PantsImg, ( int ( self.PantsImg.get_rect().size[ 0 ] * PIXEL_SIZE ), int ( self.PantsImg.get_rect().size[ 1 ] * PIXEL_SIZE ) ) )


        self.WeaponImg = pygame.image.load( "Assets/Character Encounter/Weapon/" + str( AnimNum ) + "/" + str( self.Frame ) + "/Weapon_" + str( self.p_Class ) + ".png" )
        self.WeaponImg = pygame.transform.scale( self.WeaponImg, ( int ( self.WeaponImg.get_rect().size[ 0 ] * PIXEL_SIZE ), int ( self.WeaponImg.get_rect().size[ 1 ] * PIXEL_SIZE ) ) )

        self.ShieldImg = pygame.image.load( "Assets/Character Encounter/Shield/" + str( AnimNum ) + "/Shield_" + str( self.Frame + 1 ) + ".png" )
        self.ShieldImg = pygame.transform.scale( self.ShieldImg, ( int ( self.ShieldImg.get_rect().size[ 0 ] * PIXEL_SIZE ), int ( self.ShieldImg.get_rect().size[ 1 ] * PIXEL_SIZE ) ) )


        DISPLAYSURF.blit( self.HairImg, ( self.x, self.y, int ( self.HairImg.get_rect().size[ 0 ] ) * PIXEL_SIZE, int ( self.HairImg.get_rect().size[ 1 ] ) * PIXEL_SIZE ) )
        DISPLAYSURF.blit( self.SkinImg, ( self.x, self.y, int ( self.SkinImg.get_rect().size[ 0 ] ) * PIXEL_SIZE, int ( self.SkinImg.get_rect().size[ 1 ] ) * PIXEL_SIZE ) )
        DISPLAYSURF.blit( self.EyesImg, ( self.x, self.y, int ( self.EyesImg.get_rect().size[ 0 ] ) * PIXEL_SIZE, int ( self.EyesImg.get_rect().size[ 1 ] ) * PIXEL_SIZE ) )
        DISPLAYSURF.blit( self.BandanaImg, ( self.x, self.y, int ( self.BandanaImg.get_rect().size[ 0 ] ) * PIXEL_SIZE, int ( self.BandanaImg.get_rect().size[ 1 ] ) * PIXEL_SIZE ) )
        DISPLAYSURF.blit( self.ShirtImg, ( self.x, self.y, int ( self.ShirtImg.get_rect().size[ 0 ] ) * PIXEL_SIZE, int ( self.ShirtImg.get_rect().size[ 1 ] ) * PIXEL_SIZE ) )
        DISPLAYSURF.blit( self.PantsImg, ( self.x, self.y, int ( self.PantsImg.get_rect().size[ 0 ] ) * PIXEL_SIZE, int ( self.PantsImg.get_rect().size[ 1 ] ) * PIXEL_SIZE ) )

        DISPLAYSURF.blit( self.WeaponImg, ( self.x, self.y, int ( self.WeaponImg.get_rect().size[ 0 ] ) * PIXEL_SIZE, int ( self.WeaponImg.get_rect().size[ 1 ] ) * PIXEL_SIZE ) )
        DISPLAYSURF.blit( self.ShieldImg, ( self.x, self.y, int ( self.ShieldImg.get_rect().size[ 0 ] ) * PIXEL_SIZE, int ( self.ShieldImg.get_rect().size[ 1 ] ) * PIXEL_SIZE ) )

    def Attack( self, attack, target ):

            # If the attack is the regular attack,
        if attack == 0:
                # damage the target ( str * 2 for damage )
            target.health -= self.strength * 2

            AttackSound = pygame.mixer.Sound( "sfx/zapsplat_warfare_sword_swipe_body_hit_slash_20827.wav" )
            AttackSound.play()

            # If the attack
        elif attack == 1:
            print( "ATTACK 2" )
















class Enemy:

    def __init__( self, type, level ):
        self.level = level
        self.type = type

        self.name = MonsterStats[ self.type ][ 0 ]
        self.health = int( MonsterStats[ self.type ][ 1 ] * ( 9 + level ) )
        self.MAX_health = int( MonsterStats[ self.type ][ 1 ] * ( 9 + level ) )
        self.damage = MonsterStats[ self.type ][ 2 ] * ( 9 + level )
        self.attacks = [ MonsterStats[ self.type ][ 3 ], MonsterStats[ self.type ][ 7 ] ]
        self.attackDamages = [ MonsterStats[ self.type ][ 4 ], MonsterStats[ self.type ][ 8 ] ]
        self.attackTypes = [ MonsterStats[ self.type ][ 5 ], MonsterStats[ self.type ][ 9 ] ]
        self.attackSounds = [ pygame.mixer.Sound( "sfx/" + MonsterStats[ self.type ][ 6 ] ), pygame.mixer.Sound( "sfx/" + MonsterStats[ self.type ][ 10 ] ) ]
        self.defence = int( MonsterStats[ self.type ][ 11 ] * ( 9 + level ) )
        self.speed = int( MonsterStats[ self.type ][ 12 ] *  ( 9 + level ) )

        self.frame = 1
        self.timer = 0
        self.Anim = 0

        self.x = 0
        self.y = 0

            # Initiate image for positioning
        self.image = pygame.image.load( "Assets/Enemies/" + self.name + "/0/sprite_" + str( self.frame ) + ".png" )
        self.image = pygame.transform.scale( self.image, ( int ( self.image.get_rect().size[ 0 ] * PIXEL_SIZE ), int ( self.image.get_rect().size[ 1 ] * PIXEL_SIZE ) ) )

        self.Attacked = False   # Holds whether the enemy's attack is finished



    def SetPos( self, x, y ):
        self.x = x
        self.y = y



    def Render( self, Anim, target, Frame = None ):
            # Check if the animation is the same as the one running
        if self.Anim == Anim:
            self.timer += 1
            if self.timer >= MonsterAnimSpeed[ self.type ][ Anim ]:
                self.timer = 0
                self.frame += 1

            # Else, change the current animation
        else:
            self.Anim = Anim
            self.frame = 1
            self.Attacked = False


            # If a frame has been selected, print that frame
        if Frame != None:
            self.frame = Frame


            # If the frame is at the end of an animation
        if self.frame > MonsterAnimLength[ self.type ][ self.Anim ]:

                # If the animation was the end of an attack animation, make the target take damage
            if target != None:
                if self.Anim == ATTACK_1:
                            # Attack with the first attack
                        self.Attack( 0, target )

                            # If the attack can happen more than once, check if the attack occurs again
                        if self.attackTypes[ 0 ] == BARRAGE:

                            if random.randint( 1, 3 ) == 1:

                                self.Attacked = True    # If the attack is ended, set self.Attacked to show it

                        else:
                            self.Attacked = True    # If the attack is ended, set self.Attacked to show it

                elif self.Anim == ATTACK_2:
                            # Attack with the second attack
                        self.Attack( 1, target )

                            # If the attack can happen more than once, check if the attack occurs again
                        if self.attackTypes[ 1 ] == BARRAGE:

                            if random.randint( 1, 5 ) == 1:

                                self.Attacked = True    # If the attack is ended, set self.Attacked to show it

                        else:
                            self.Attacked = True    # If the attack is ended, set self.Attacked to show it

                # Loop animation
            self.frame = 1

            # Load the image depending on the enemy, animation and frame
        self.image = pygame.image.load( "Assets/Enemies/" + self.name + "/" + str( Anim ) + "/sprite_" + str( self.frame ) + ".png" )
        self.image = pygame.transform.scale( self.image, ( int ( self.image.get_rect().size[ 0 ] * PIXEL_SIZE ), int ( self.image.get_rect().size[ 1 ] * PIXEL_SIZE ) ) )

            # Print image onto the screen
        DISPLAYSURF.blit( self.image, ( self.x, self.y, int ( self.image.get_rect().size[ 0 ] * PIXEL_SIZE ), int ( self.image.get_rect().size[ 1 ] * PIXEL_SIZE ) ) )



    def Attack( self, attack, target ):

            # If the attack heals the attacker
        if self.attackTypes[ attack ] == HEAL:
                # Restore some of the enemy's health
            self.health += self.attackDamages[ attack ]

            # If the attack is a regular attack,
        else:
            AttackSound = pygame.mixer.Sound( self.attackSounds[ attack ] )
            AttackSound.play()

                # damage the target ( use the attack's damage and multiply it by the enemy's damage )
            if self.attackDamages[ attack ] * self.damage - target.defence > 0:
                target.health -= self.attackDamages[ attack ] * self.damage - target.defence
            else:
                target.health -= 1














def BossFight( P1 ):
        # Declare global difficulty
    global SONG_FINISHED
    global Difficulty

        # Set the music
    pygame.mixer.music.stop()
    pygame.mixer.music.load( "Music/wav/EventTrack.wav" )
    pygame.mixer.music.play()

        # Check if difficulty is 0
    if Difficulty <= 0:
        Difficulty = 1  # If difficulty is 0, set it to 1


    Boss = Enemy( len( MonsterStats ) - 1, Difficulty )       # Create the enemy
    Boss.SetPos( PIXEL_SIZE * 38, BATTLE_Y )                  # Set the enemy's position

    B_Timer = 100          # Timer for the enemy's turn
    B_TurnBar = pygame.Rect( PIXEL_SIZE * 45, BATTLE_Y - PIXEL_SIZE * 2, PIXEL_SIZE * 10, PIXEL_SIZE )    # Bar to show the remainder of the enemy's timer
    BossAnim = IDLE        # The current animation plated by the enemy

    P1.SetPos( BATTLE_X, BATTLE_Y )   # Set the player's position
    P_Timer = 1000                    # Timer for the player's turn
    P_TurnBar = pygame.Rect( PIXEL_SIZE * 10, BATTLE_Y - PIXEL_SIZE * 2, PIXEL_SIZE * 10, PIXEL_SIZE )     # Bar to show the remainder of the player's timer



    PlayerTurn = False          # Holds whether the player's turn is in progress
    BossTurn = False            # Holds whether the enemy's turn is in progress
    PlayerAttacking = False     # Holds whether the player is attacking
    BossAttacking = False       # Holds whether the enemy is attacking
    CollectedLoot = False       # Holds whether rewards have been taken yet


    Pause4Effect = 0                # A small timer that delays the return to the "Waiting" faze
    ButtonPressed = None            # Holds what button has been pressed
    CurrentMenu = ATTACK_ENCOUNTER  # Holds the menu that the player is on



    Background = pygame.image.load( "Assets/Backgrounds/Background_10.png" )  # Load the background depending on the biome
    Background = pygame.transform.scale( Background, ( SCREEN_WIDTH, SCREEN_HEIGHT ) )              # Stretch the background to fill the screen


        # Main battle loop
    while True:

            # Handle events
        for event in pygame.event.get():

                # If the song has ended, replay
            if event.type == SONG_FINISHED:
                pygame.mixer.music.play()

                # If the red X is clicked, quit the program
            if event.type == QUIT:

                pygame.quit()
                sys.exit()

                # If the mouse is clicked...
            elif event.type == MOUSEBUTTONDOWN:

                    # ...check if it's the player's turn
                if PlayerTurn:

                        # Find what button the player clicked ( None if they didn't click any )
                    ButtonPressed = GetButtonPressed( CurrentMenu )

                elif  Boss.health <= 0:

                    return



            # Check if someone's turn is in progress or if anyone has died / won
        if not PlayerTurn and not PlayerAttacking and not BossTurn and not BossAttacking and Boss.health > 0 and P1.health > 0:

            P_Timer -= P1.speed                                 # Advance the player's timer
            P_TurnBar.w = int( P_Timer / 100 ) * PIXEL_SIZE     # Update the pink bar depending on the remaning time until the player's turn

                # Check if the player's timer has reached 0
            if P_Timer <= 0:
                PlayerTurn = True   # Start the player's turn
                P_Timer += 1000     # Reset the player's timer

                # If the player's timer has not reached 0
            else:

                B_Timer -= 1                            # Advance the enemy's timer
                B_TurnBar.w = int ( B_Timer / 10 ) * PIXEL_SIZE      # Update the pink bar depending on the remaning time until the enemy's turn

                    # Check if the enemy's timer has reached 0
                if B_Timer <= 0:
                    BossTurn = True     # Start the enemy's turn
                    B_Timer += 100      # Reset the enemy's timer




            # Check if the player's turn is in progress
        if PlayerTurn:

                # Check if the current popup menu is the ATTACK_ENCOUNTER menu
            if CurrentMenu == ATTACK_ENCOUNTER:

                    # If the ATTACK button has been pressed...
                if ButtonPressed == 0:
                    PlayerAttacking = True                          # Start the player's attack
                    P1.SetPos( PIXEL_SIZE * 30, PIXEL_SIZE * 1 )    # Set the player's position to melee range


            # Check if the boss' turn is in progress
        elif BossTurn:

                # Randomly choose which attack to use
            AttackNum = random.randint( 1, 3 )
            if AttackNum < 3:
                Boss.SetPos( BATTLE_X, BATTLE_Y )
                BossAnim = ATTACK_1

            else:
                BossAnim = ATTACK_2

            BossTurn = False
            BossAttacking = True






                # Render everything
        DISPLAYSURF.blit( Background, ( 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT ) )       # Render the Background


            # Check if the enemy is still alive
        if Boss.health > 0:
            if BossAttacking:

                    # Check if the boss has finished their attack
                if Boss.Attacked:
                    Pause4Effect += 1   # Advance the "Pause for effect" timer
                    Boss.Render( BossAnim, P1, MonsterAnimLength[ len( MonsterStats ) - 1 ][ BossAnim ] )

                        # If the boss has paused of a reasonable amount of time...
                    if Pause4Effect >= 30:

                        BossAttacking = False                       # End the boss' attacking faze
                        BossTurn = False                            # End the boss' turn
                        Boss.SetPos( PIXEL_SIZE * 38, BATTLE_Y )    # Set the boss' position back to normal

                        Pause4Effect = 0                # Reset the "Pause for effect" timer
                else:
                    Boss.Render( BossAnim, P1 )

            else:
                Boss.Render( IDLE, P1 )  # Blit the enemy onto the screen



            # Check if the player is attacking
        if PlayerAttacking:
            P1.Render( 1, Boss, ButtonPressed )   # Blit the player onto the screen

                # If the player has finished their attack...
            if P1.Attacked:
                Pause4Effect += 1   # ... advance the "Pause for effect" timer

                    # If the player has paused of a reasonable amount of time...
                if Pause4Effect >= 15:

                    PlayerAttacking = False                             # End the player's attacking faze
                    PlayerTurn = False                                  # End the player's turn
                    P1.SetPos( BATTLE_X, BATTLE_Y )                     # Set the player's position back to normal

                    Pause4Effect = 0                # Reset the "Pause for effect" timer
                    CurrentMenu = ATTACK_ENCOUNTER  # Reset the popup menu
                    ButtonPressed = None            # Reset the button pressed


        else:                   # If the player is not attacking...
            P1.Render( IDLE )   # ... Render the player in the idle animation



            # Make sure that no one's turn is in progress or if anyone has died
        if not PlayerTurn and not PlayerAttacking and not BossTurn and not BossAttacking and Boss.health > 0 and P1.health > 0:
            pygame.draw.rect( DISPLAYSURF, ( 255, 0 , 255 ), B_TurnBar )    # Blit the enemy's remaining turn timer bar onto the screen
            pygame.draw.rect( DISPLAYSURF, ( 255, 0 , 255 ), P_TurnBar )    # Blit the player's remaining turn timer bar onto the screen


            # Make sure the player isn't attacking or anyone has won
        if not PlayerAttacking and Boss.health > 0 and P1.health > 0:
                # Draw the player's heath bar onto the screen
            pygame.draw.rect( DISPLAYSURF, ( 255, 0, 0 ), ( PIXEL_SIZE * 10, BATTLE_Y - int ( PIXEL_SIZE * 3.5 ), int ( P1.health / 10 ) * PIXEL_SIZE, PIXEL_SIZE ) )


            # Make sure the enemy isn't attacking or dead
        if not BossAttacking and Boss.health > 0:
                # Draw the enemy's heath bar onto the screen
            pygame.draw.rect( DISPLAYSURF, ( 255, 0, 0 ), ( PIXEL_SIZE * 45, BATTLE_Y - int ( PIXEL_SIZE * 3.5 ), int ( Boss.health / 10 ) * PIXEL_SIZE, PIXEL_SIZE ) )


            # Check if it is the player's turn but the player hasn't attacked yet
        if PlayerTurn and not PlayerAttacking:
            PrintMenu( CurrentMenu )    # Blit a popup menu onto the screen



            # Check if the enemy is dead
        if Boss.health <= 0 and Pause4Effect <= 0:
            Awards = PrintAwards( Boss )  # Blit gold and xp rewards onto the screen

                # Check if the player has already recieved gold and xp for this battle
            if not CollectedLoot:
                P1.Gold += Awards[ 0 ]  # Give the player their earned gold
                P1.Xp += Awards[ 1 ]    # Give the player their earned xp
                CollectedLoot = True    # Make sure the player doesn't get extra awards
                Difficulty += 1         # Increase the game's difficulty slightly

        if P1.health <= 0:
            GameOver()



            # Render the mouse
        DISPLAYSURF.blit( MouseIMG, ( pygame.mouse.get_pos()[ 0 ], pygame.mouse.get_pos()[ 1 ], MOUSE_SIZE, MOUSE_SIZE ) )


            # Update the screen
        pygame.display.update()














class Tile:

    def __init__ ( self, x, y, w, h, path, BlocksPlayer, TriggersBattle, TriggersShop, ItemCondition = None ):

        self.x = x
        self.y = y
        self.w = w
        self.h = h

        self.Image = pygame.image.load( path )
        self.Image = pygame.transform.scale( self.Image, ( self.w, self.h ) )

        self.BlocksPlayer = BlocksPlayer
        self.BattleTrig = TriggersBattle
        self.ShopTrig = TriggersShop

        self.ItemCondition = ItemCondition

    def Render( self ):
        DISPLAYSURF.blit( self.Image, ( self.x, self.y, self.w, self.h ) )

    def RenderCam( self, camX, camY ):
        DISPLAYSURF.blit( self.Image, ( self.x - camX, self.y - camY, self.w, self.h ) )

    def GetItemReq( self, P1 ):
        if self.ItemCondition != None:
            if self.ItemCondition in P1.Items:
                if self.ItemCondition == "Battering Ram":
                    BossFight( P1 )
                    return 0
                elif self.ItemCondition == "Torch":
                    if self.x > self.w * 85:
                        P1.SetPos( self.w * 60, self.h * 90 )
                    else:
                        P1.SetPos( self.w * 78, self.h * 98 )

                    return 1

                else:
                    return 2
            else:
                return 3
        else:
            return 3

    def GetCollision( self, x, y, w, h, P1 = None, TileOn = None ):
        return not (
            x       >= self.x + self.w   or
            x + w   < self.x            or
            y       >= self.y + self.h   or
            y + h   < self.y
            )






























































"""
def DoneCheck( Array1, Array2, Array3, Number ):
    return  (   not Number in Array1 and
                not Number in Array2 and
                not Number in Array3 )



def FindPath( Tiles, Start, End, TilesCross, TilesUp ):

    Walls = []
    for i in Tiles:
        if i.BlocksPlayer:
            Walls.append( i )

    Connections = []

    Frontier = deque()
    Frontier.append( Start )

    Visited = []

    while len( Frontier ) > 0:
        CurrentTile = Frontier.popleft()

"""





































































    # Function for the main menu
def MainMenu():
    global SONG_FINISHED

        # Sets the writing at the top of the window
    pygame.display.set_caption( "MAIN_MENU" )

        # Set music
    #pygame.mixer.music.set_endevent( SONG_FINISHED )
    #pygame.mixer.music.load( "Music/wav/MapTrack.wav" )
    #pygame.mixer.music.play()

        # Creates a variable for the background
    Background = LoadBackground( 1 )

        # Create all of the main menu's buttons
    PlayButton = Button( "Assets/Buttons/Play.png", SCREEN_WIDTH / 2 - 150, SCREEN_HEIGHT / 2, 300, 125 )
    OptionsButton = Button( "Assets/Buttons/Cog.png", 0, 0, 50, 50 )
    MuteButton = Button( "Assets/Buttons/Mute_1.png", 60, 0, 50, 50 )

        # Main menu loop
    while True:

            # Handle mouse events
        for event in pygame.event.get():
                    # Check what 'event' is
                # IF event is the music ending, play it again
            if event.type == SONG_FINISHED:
                pygame.mixer.music.play()

                # IF event is the red X of the window, exit the game
            elif event.type == QUIT:

                pygame.quit()
                sys.exit()

                # IF event is the mouse being pressed, check if a button has been pressed
            elif event.type == MOUSEBUTTONDOWN:

                    # If the Play button was clicked, change scene to the
                    # character creation screen
                if PlayButton.Clicked():
                    return CHARACTER_CREATION

                    # If the Options button was clicked, change scene to the
                    # options screen
                elif OptionsButton.Clicked():
                    return OPTIONS_MENU

                    # If the mute button was clicked, toggle mute and change the
                    # look of the mute button
                elif MuteButton.Clicked():

                    global Muted
                    Muted = ( not Muted )

                    if Muted == True:
                        MuteButton.SetImage( "Assets/Buttons/Mute_2.png" )
                    else:
                        MuteButton.SetImage( "Assets/Buttons/Mute_1.png" )


                # Render everything
            # Render the background
        DISPLAYSURF.blit( Background, ( 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT ) )

            # Render all of the buttons
        PlayButton.Render()
        OptionsButton.Render()
        MuteButton.Render()

            # Render the mouse
        DISPLAYSURF.blit( MouseIMG, ( pygame.mouse.get_pos()[ 0 ], pygame.mouse.get_pos()[ 1 ], MOUSE_SIZE, MOUSE_SIZE ) )


            # Updates the screen
        pygame.display.update()












def CharacterCreation():
    global Difficulty
    global SONG_FINISHED

        # Sets the writing at the top of the window
    pygame.display.set_caption( "CHARACTER_CREATION" )

        # Create a sound for the user's clicks
    ClickSound = pygame.mixer.Sound( "sfx/zapsplat_impacts_stick_branch_large_drop_ground_25055.wav" )

        # Creates a variable for the background
    Background = LoadBackground( 2 )

        # Variables for the pixel size on this screen
    PIXEL_SIZE = int ( SCREEN_WIDTH / 60 )

        # Create a label for the difficulty bar
    Font = pygame.font.SysFont( "luxirb.ttf", 56 )   # Holds the font for the Label
    DifficultyLabel = Font.render( "easy         DIFFICULTY         hard", True, ( 0, 0, 0 ) )

        # Create all the buttons ( Damn thats a lot )
    FighterButton = Button( "Assets/Buttons/Class_1_1.png", PIXEL_SIZE * 32, PIXEL_SIZE * 15, PIXEL_SIZE * 8, PIXEL_SIZE * 11 )
    ArcherButton = Button( "Assets/Buttons/Class_2_1.png", PIXEL_SIZE * 41, PIXEL_SIZE * 15, PIXEL_SIZE * 8, PIXEL_SIZE * 11 )
    WizardButton = Button( "Assets/Buttons/Class_3_1.png", PIXEL_SIZE * 50, PIXEL_SIZE * 15, PIXEL_SIZE * 8, PIXEL_SIZE * 11 )


    PrevHair = Button( "Assets/Buttons/Arrow_Left.png", PIXEL_SIZE * 19, PIXEL_SIZE * 15, PIXEL_SIZE * 2, PIXEL_SIZE * 3 )
    NextHair = Button( "Assets/Buttons/Arrow_Right.png", PIXEL_SIZE * 28, PIXEL_SIZE * 15, PIXEL_SIZE * 2, PIXEL_SIZE * 3 )

    PrevSkin = Button( "Assets/Buttons/Arrow_Left.png", PIXEL_SIZE * 19, PIXEL_SIZE * 19, PIXEL_SIZE * 2, PIXEL_SIZE * 3 )
    NextSkin = Button( "Assets/Buttons/Arrow_Right.png", PIXEL_SIZE * 28, PIXEL_SIZE * 19, PIXEL_SIZE * 2, PIXEL_SIZE * 3 )

    PrevEyes = Button( "Assets/Buttons/Arrow_Left.png", PIXEL_SIZE * 19, PIXEL_SIZE * 23, PIXEL_SIZE * 2, PIXEL_SIZE * 3 )
    NextEyes = Button( "Assets/Buttons/Arrow_Right.png", PIXEL_SIZE * 28, PIXEL_SIZE * 23, PIXEL_SIZE * 2, PIXEL_SIZE * 3 )

    PrevBandana = Button( "Assets/Buttons/Arrow_Left.png", PIXEL_SIZE * 19, PIXEL_SIZE * 27, PIXEL_SIZE * 2, PIXEL_SIZE * 3 )
    NextBandana = Button( "Assets/Buttons/Arrow_Right.png", PIXEL_SIZE * 28, PIXEL_SIZE * 27, PIXEL_SIZE * 2, PIXEL_SIZE * 3 )

    PrevShirt = Button( "Assets/Buttons/Arrow_Left.png", PIXEL_SIZE * 19, PIXEL_SIZE * 31, PIXEL_SIZE * 2, PIXEL_SIZE * 3 )
    NextShirt = Button( "Assets/Buttons/Arrow_Right.png", PIXEL_SIZE * 28, PIXEL_SIZE * 31, PIXEL_SIZE * 2, PIXEL_SIZE * 3 )

    PrevPants = Button( "Assets/Buttons/Arrow_Left.png", PIXEL_SIZE * 19, PIXEL_SIZE * 35, PIXEL_SIZE * 2, PIXEL_SIZE * 3 )
    NextPants = Button( "Assets/Buttons/Arrow_Right.png", PIXEL_SIZE * 28, PIXEL_SIZE * 35, PIXEL_SIZE * 2, PIXEL_SIZE * 3 )

    PrevColour = Button( "Assets/Buttons/Arrow_Left.png", PIXEL_SIZE * 39, PIXEL_SIZE * 27, PIXEL_SIZE * 2, PIXEL_SIZE * 3 )
    NextColour = Button( "Assets/Buttons/Arrow_Right.png", PIXEL_SIZE * 49, PIXEL_SIZE * 27, PIXEL_SIZE * 2, PIXEL_SIZE * 3 )

    NextScreen = Button( "Assets/Buttons/Arrow_Right.png", PIXEL_SIZE * 56, PIXEL_SIZE * 35, PIXEL_SIZE * 2, PIXEL_SIZE * 3 )

        # Create a blach bar out of 20 buttons to create a difficulty select
    DifficultyButtons = []
    for i in range ( 0, 20 ):
        DifficultyButtons.append( Button( "Assets/Backgrounds/Background_3.png", PIXEL_SIZE * ( 18.5 + i * 2 ), PIXEL_SIZE * 12, PIXEL_SIZE * 2, PIXEL_SIZE * 2 ) )


        # Variables holding what colours / styles that were chosen
    HairNo = 1
    SkinNo = 1
    EyesNo = 1
    BandanaNo = 1
    ShirtNo = 1
    PantsNo = 1
    ColourNo = 1

    ClassNo = 0
    DifficultyNo = -1

        # Create all of the changable icons
    HairIcon = pygame.image.load( "Assets/Character Creation Icons/Hair/Hair_1.png" )
    HairIcon = pygame.transform.scale( HairIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

    SkinIcon = pygame.image.load( "Assets/Character Creation Icons/Skin/Skin_1.png" )
    SkinIcon = pygame.transform.scale( SkinIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

    EyesIcon = pygame.image.load( "Assets/Character Creation Icons/Eyes/Eyes_1.png" )
    EyesIcon = pygame.transform.scale( EyesIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

    BandanaIcon = pygame.image.load( "Assets/Character Creation Icons/Bandana/Bandana_1.png" )
    BandanaIcon = pygame.transform.scale( BandanaIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

    ShirtIcon = pygame.image.load( "Assets/Character Creation Icons/Shirt/Shirt_1.png" )
    ShirtIcon = pygame.transform.scale( ShirtIcon, ( PIXEL_SIZE * 5, PIXEL_SIZE * 3 ) )

    PantsIcon = pygame.image.load( "Assets/Character Creation Icons/Pants/Pants_1.png" )
    PantsIcon = pygame.transform.scale( PantsIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

    ColourIcon = pygame.image.load( "Assets/Character Creation Icons/Colour/Colour_1.png" )
    ColourIcon = pygame.transform.scale( ColourIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )



        # Create the different parts of the character on the left
    DisplayHair = pygame.image.load( "Assets/Character/Hair/Big/Hair_1.png" )
    DisplayHair = pygame.transform.scale( DisplayHair, ( PIXEL_SIZE * 7, PIXEL_SIZE * 7 ) )

    DisplaySkin = pygame.image.load( "Assets/Character/Skin/Big/Skin_1.png" )
    DisplaySkin = pygame.transform.scale( DisplaySkin, ( PIXEL_SIZE * 8, PIXEL_SIZE * 15 ) )

    DisplayEyes = pygame.image.load( "Assets/Character/Eyes/Eyes_1.png" )
    DisplayEyes = pygame.transform.scale( DisplayEyes, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

    DisplayBandana = pygame.image.load( "Assets/Character/Bandana/Big/Bandana_1.png" )
    DisplayBandana = pygame.transform.scale( DisplayBandana, ( PIXEL_SIZE * 7, PIXEL_SIZE * 4 ) )

    DisplayShirt = pygame.image.load( "Assets/Character/Shirt/Big/Shirt_1.png" )
    DisplayShirt = pygame.transform.scale( DisplayShirt, ( PIXEL_SIZE * 8, PIXEL_SIZE * 10 ) )

    DisplayPants = pygame.image.load( "Assets/Character/Pants/Big/Pants_1.png" )
    DisplayPants = pygame.transform.scale( DisplayPants, ( PIXEL_SIZE * 11, PIXEL_SIZE * 8 ) )

    Shield = pygame.image.load( "Assets/Character/Shield.png" )
    Shield = pygame.transform.scale( Shield, ( PIXEL_SIZE * 5, PIXEL_SIZE * 10 ) )

    Sword = pygame.image.load( "Assets/Character/Sword.png" )
    Sword = pygame.transform.scale( Sword, ( PIXEL_SIZE * 5, PIXEL_SIZE * 5 ) )


        # Character creation main loop
    while True:

            # Handle events
        for event in pygame.event.get():

                # If the song has ended, replay the song
            if event.type == SONG_FINISHED:
                pygame.mixer.music.play()

                # If red X is pressed, quit
            elif event.type == QUIT:

                    # Exit the program
                pygame.quit()
                sys.exit()

                # If the mouse is clicked, check if the mouse was over any buttons
            elif event.type == MOUSEBUTTONDOWN:

                    # Make a sound :)
                ClickSound.play()

                    # If a class button has been pressed, make it coloured and set the
                    # class
                if FighterButton.Clicked():
                    FighterButton.SetImage( "Assets/Buttons/Class_1_2.png" )
                    ArcherButton.SetImage( "Assets/Buttons/Class_2_1.png" )
                    WizardButton.SetImage( "Assets/Buttons/Class_3_1.png" )

                    ClassNo = 1

                    # ARCHER DOESN'T EXIST IN THIS VERSION OF THE GAME!!!
                    # ALLOWING THE USER TO SELECT IT WILL RESULT IN A CRASH DURING ANY ENCOUNTER
                elif ArcherButton.Clicked():
                    #ArcherButton.SetImage( "Assets/Buttons/Class_2_2.png" )
                    #FighterButton.SetImage( "Assets/Buttons/Class_1_1.png" )
                    WizardButton.SetImage( "Assets/Buttons/Class_3_1.png" )\

                    #ClassNo = 2

                    # MAGE DOESN'T EXIST IN THIS VERSION OF THE GAME!!!
                    # ALLOWING THE USER TO SELECT IT WILL RESULT IN A CRASH DURING ANY ENCOUNTER
                elif WizardButton.Clicked():
                    #WizardButton.SetImage( "Assets/Buttons/Class_3_2.png" )
                    #FighterButton.SetImage( "Assets/Buttons/Class_1_1.png" )
                    ArcherButton.SetImage( "Assets/Buttons/Class_2_1.png" )

                    #ClassNo = 3



                    # If a hair arrow has been pressed, go to the next / prev
                    # hair
                # If the left hair arrow is pressed
                elif PrevHair.Clicked():
                    HairNo -= 1
                    if HairNo == 0:
                        HairNo = 9

                        # Set the look of the changing hair icon
                    HairIcon = pygame.image.load( "Assets/Character Creation Icons/Hair/Hair_" + str( HairNo ) + ".png" )
                    HairIcon = pygame.transform.scale( HairIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

                        # Set the look of the character to the left's hair
                    DisplayHair = pygame.image.load( "Assets/Character/Hair/Big/Hair_" + str( HairNo ) + ".png" )
                    DisplayHair = pygame.transform.scale( DisplayHair, ( PIXEL_SIZE * 7, PIXEL_SIZE * 7 ) )

                # If the right hair arrow is pressed
                elif NextHair.Clicked():
                    HairNo += 1
                    if HairNo == 10:
                        HairNo = 1

                        # Set the look of the changing hair icon
                    HairIcon = pygame.image.load( "Assets/Character Creation Icons/Hair/Hair_" + str( HairNo ) + ".png" )
                    HairIcon = pygame.transform.scale( HairIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

                        # Set the look of the character to the left's hair
                    DisplayHair = pygame.image.load( "Assets/Character/Hair/Big/Hair_" + str( HairNo ) + ".png" )
                    DisplayHair = pygame.transform.scale( DisplayHair, ( PIXEL_SIZE * 7, PIXEL_SIZE * 7 ) )



                    # If a skin arrow has been pressed, go to the next / prev
                    # skin
                elif PrevSkin.Clicked():
                    SkinNo -= 1
                    if SkinNo == 0:
                        SkinNo = 5

                        # Set the look of the changing skin Icon
                    SkinIcon = pygame.image.load( "Assets/Character Creation Icons/Skin/Skin_" + str( SkinNo ) + ".png" )
                    SkinIcon = pygame.transform.scale( SkinIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

                        # Set the look of the character to the left's skin
                    DisplaySkin = pygame.image.load( "Assets/Character/Skin/Big/Skin_" + str( SkinNo ) + ".png" )
                    DisplaySkin = pygame.transform.scale( DisplaySkin, ( PIXEL_SIZE * 8, PIXEL_SIZE * 15 ) )

                elif NextSkin.Clicked():
                    SkinNo += 1
                    if SkinNo == 6:
                        SkinNo = 1

                        # Set the look of the changing skin icon
                    SkinIcon = pygame.image.load( "Assets/Character Creation Icons/Skin/Skin_" + str( SkinNo ) + ".png" )
                    SkinIcon = pygame.transform.scale( SkinIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

                        # Set the look of the character to the left's skin
                    DisplaySkin = pygame.image.load( "Assets/Character/Skin/Big/Skin_" + str( SkinNo ) + ".png" )
                    DisplaySkin = pygame.transform.scale( DisplaySkin, ( PIXEL_SIZE * 8, PIXEL_SIZE * 15 ) )




                    # If an eyes arrow has been pressed, go to the next / prev
                    # eyes
                elif PrevEyes.Clicked():
                    EyesNo -= 1
                    if EyesNo == 0:
                        EyesNo = 5

                        # Set the look of the changing skin Icon
                    EyesIcon = pygame.image.load( "Assets/Character Creation Icons/Eyes/Eyes_" + str( EyesNo ) + ".png" )
                    EyesIcon = pygame.transform.scale( EyesIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

                        # Set the look of the character to the left's eyes
                    DisplayEyes = pygame.image.load( "Assets/Character/Eyes/Eyes_" + str( EyesNo ) + ".png" )
                    DisplayEyes = pygame.transform.scale( DisplayEyes, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

                elif NextEyes.Clicked():
                    EyesNo += 1
                    if EyesNo == 6:
                        EyesNo = 1

                        # Set the look of the changing eyes icon
                    EyesIcon = pygame.image.load( "Assets/Character Creation Icons/Eyes/Eyes_" + str( EyesNo ) + ".png" )
                    EyesIcon = pygame.transform.scale( EyesIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

                        # Set the look of the character to the left's skin
                    DisplayEyes = pygame.image.load( "Assets/Character/Eyes/Eyes_" + str( EyesNo ) + ".png" )
                    DisplayEyes = pygame.transform.scale( DisplayEyes, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )


                    # If a bandana arrow has been pressed, go to the next / prev
                    # bandana
                elif PrevBandana.Clicked():
                    BandanaNo -= 1
                    if BandanaNo == 0:
                        BandanaNo = 5

                        # Set the look of the changing shirt icon
                    BandanaIcon = pygame.image.load( "Assets/Character Creation Icons/Bandana/Bandana_" + str( BandanaNo ) + ".png" )
                    BandanaIcon = pygame.transform.scale( BandanaIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

                        # Set the look of the character to the left's skin
                    DisplayBandana = pygame.image.load( "Assets/Character/Bandana/Big/Bandana_" + str( BandanaNo ) + ".png" )
                    DisplayBandana = pygame.transform.scale( DisplayBandana, ( PIXEL_SIZE * 7, PIXEL_SIZE * 4 ) )

                elif NextBandana.Clicked():
                    BandanaNo += 1
                    if BandanaNo == 6:
                        BandanaNo = 1

                        # Set the look of the changing shirt icon
                    BandanaIcon = pygame.image.load( "Assets/Character Creation Icons/Bandana/Bandana_" + str( BandanaNo ) + ".png" )
                    BandanaIcon = pygame.transform.scale( BandanaIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

                        # Set the look of the character to the left's skin
                    DisplayBandana = pygame.image.load( "Assets/Character/Bandana/Big/Bandana_" + str( BandanaNo ) + ".png" )
                    DisplayBandana = pygame.transform.scale( DisplayBandana, ( PIXEL_SIZE * 7, PIXEL_SIZE * 4 ) )


                    # If a shirt arrow has been pressed, go to the next / prev
                    # shirt
                elif PrevShirt.Clicked():
                    ShirtNo -= 1
                    if ShirtNo == 0:
                        ShirtNo = 11

                        # Set the look of the changing shirt icon
                    ShirtIcon = pygame.image.load( "Assets/Character Creation Icons/Shirt/Shirt_" + str( ShirtNo ) + ".png" )
                    ShirtIcon = pygame.transform.scale( ShirtIcon, ( PIXEL_SIZE * 5, PIXEL_SIZE * 3 ) )

                        # Set the look of the character to the left's skin
                    DisplayShirt = pygame.image.load( "Assets/Character/Shirt/Big/Shirt_" + str( ShirtNo ) + ".png" )
                    DisplayShirt = pygame.transform.scale( DisplayShirt, ( PIXEL_SIZE * 8, PIXEL_SIZE * 10 ) )

                elif NextShirt.Clicked():
                    ShirtNo += 1
                    if ShirtNo >= 12:
                        ShirtNo = 1

                        # Set the look of the changing shirt icon
                    ShirtIcon = pygame.image.load( "Assets/Character Creation Icons/Shirt/Shirt_" + str( ShirtNo ) + ".png" )
                    ShirtIcon = pygame.transform.scale( ShirtIcon, ( PIXEL_SIZE * 5, PIXEL_SIZE * 3 ) )

                        # Set the look of the character to the left's skin
                    DisplayShirt = pygame.image.load( "Assets/Character/Shirt/Big/Shirt_" + str( ShirtNo ) + ".png" )
                    DisplayShirt = pygame.transform.scale( DisplayShirt, ( PIXEL_SIZE * 8, PIXEL_SIZE * 10 ) )



                    # If a pants arrow has been pressed, go to the next / prev
                    # pants
                elif PrevPants.Clicked():
                    PantsNo -= 1
                    if PantsNo <= 0:
                        PantsNo = 5

                        # Set the look of the changing pants icon
                    PantsIcon = pygame.image.load( "Assets/Character Creation Icons/Pants/Pants_" + str( PantsNo ) + ".png" )
                    PantsIcon = pygame.transform.scale( PantsIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

                        # Set the look of the character to the left's pants
                    DisplayPants = pygame.image.load( "Assets/Character/Pants/Big/Pants_" + str( PantsNo ) + ".png" )
                    DisplayPants = pygame.transform.scale( DisplayPants, ( PIXEL_SIZE * 11, PIXEL_SIZE * 8 ) )

                elif NextPants.Clicked():
                    PantsNo += 1
                    if PantsNo >= 6:
                        PantsNo = 1

                        # Set the look of the changing shirt icon
                    PantsIcon = pygame.image.load( "Assets/Character Creation Icons/Pants/Pants_" + str( PantsNo ) + ".png" )
                    PantsIcon = pygame.transform.scale( PantsIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

                        # Set the look of the character to the left's skin
                    DisplayPants = pygame.image.load( "Assets/Character/Pants/Big/Pants_" + str( PantsNo ) + ".png" )
                    DisplayPants = pygame.transform.scale( DisplayPants, ( PIXEL_SIZE * 11, PIXEL_SIZE * 8 ) )




                    # If a colour arrow has been pressed, go to the next / prev
                    # colour
                elif PrevColour.Clicked():
                    ColourNo -= 1
                    if ColourNo <= 0:
                        ColourNo = 7

                        # Set the look of the changing pants icon
                    ColourIcon = pygame.image.load( "Assets/Character Creation Icons/Colour/Colour_" + str( ColourNo ) + ".png" )
                    ColourIcon = pygame.transform.scale( ColourIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

                elif NextColour.Clicked():
                    ColourNo += 1
                    if ColourNo >= 8:
                        ColourNo = 1

                        # Set the look of the changing shirt icon
                    ColourIcon = pygame.image.load( "Assets/Character Creation Icons/Colour/Colour_" + str( ColourNo ) + ".png" )
                    ColourIcon = pygame.transform.scale( ColourIcon, ( PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )



                elif NextScreen.Clicked():
                    if ClassNo != 1:
                        print ( "You still need to choose a class..." )

                    elif DifficultyNo < 0:
                        print ( "You still need to choose a difficulty..." )

                    else:
                        Stats = [ "John", HairNo, SkinNo, EyesNo, BandanaNo, ShirtNo, PantsNo, ColourNo, ClassNo, int( DifficultyNo * 1.5 ) ]
                        return Stats




                    # If none of the above have been clicked, check if a difficulty
                    # button has been pressed
                else:
                    for i in range ( 0, len ( DifficultyButtons ) ):
                        if DifficultyButtons[ i ].Clicked():

                                # Set all difficulty buttons to a black rectangle
                            for j in range ( 0, len ( DifficultyButtons ) ):
                                DifficultyButtons[ j ].SetImage( "Assets/Backgrounds/Background_3.png" )

                                # Set the clicked difficulty button to a white
                                # rectangle
                            DifficultyButtons[ i ].SetImage( "Assets/Backgrounds/Background_13.png" )

                            # Actually set the difficulty level
                            DifficultyNo = i




                # Render everything
            # Render the background
        DISPLAYSURF.blit( Background, ( 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT ) )

            # Render the Character on the left
        DISPLAYSURF.blit( DisplaySkin, ( PIXEL_SIZE * 4, PIXEL_SIZE * 11, PIXEL_SIZE * 7, PIXEL_SIZE * 7 ) )
        DISPLAYSURF.blit( DisplayEyes, ( PIXEL_SIZE * 9, PIXEL_SIZE * 12, PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )
        DISPLAYSURF.blit( DisplayBandana, ( PIXEL_SIZE * 5, PIXEL_SIZE * 12, PIXEL_SIZE * 7, PIXEL_SIZE * 4 ) )
        DISPLAYSURF.blit( DisplayHair, ( PIXEL_SIZE * 5, PIXEL_SIZE * 9, PIXEL_SIZE * 7, PIXEL_SIZE * 7 ) )
        DISPLAYSURF.blit( DisplayShirt, ( PIXEL_SIZE * 4, PIXEL_SIZE * 17, PIXEL_SIZE * 8, PIXEL_SIZE * 10 ) )
        DISPLAYSURF.blit( DisplayPants, ( PIXEL_SIZE * 4, PIXEL_SIZE * 27, PIXEL_SIZE * 11, PIXEL_SIZE * 8 ) )
        DISPLAYSURF.blit( Sword, ( PIXEL_SIZE * 6, PIXEL_SIZE * 25, PIXEL_SIZE * 5, PIXEL_SIZE * 10 ) )
        DISPLAYSURF.blit( Shield, ( PIXEL_SIZE * 9, PIXEL_SIZE * 18, PIXEL_SIZE * 5, PIXEL_SIZE * 10 ) )

            # Render all of the buttons
        FighterButton.Render()
        ArcherButton.Render()
        WizardButton.Render()

        PrevHair.Render()
        NextHair.Render()

        PrevSkin.Render()
        NextSkin.Render()

        PrevEyes.Render()
        NextEyes.Render()

        PrevBandana.Render()
        NextBandana.Render()

        PrevShirt.Render()
        NextShirt.Render()

        PrevPants.Render()
        NextPants.Render()

        PrevColour.Render()
        NextColour.Render()

        NextScreen.Render()

        for i in DifficultyButtons:
            i.Render()


            # Render all of the changable icons
        DISPLAYSURF.blit( HairIcon, ( PIXEL_SIZE * 23, PIXEL_SIZE * 15, PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )
        DISPLAYSURF.blit( SkinIcon, ( PIXEL_SIZE * 23, PIXEL_SIZE * 19, PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )
        DISPLAYSURF.blit( EyesIcon, ( PIXEL_SIZE * 23, PIXEL_SIZE * 23, PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )
        DISPLAYSURF.blit( BandanaIcon, ( PIXEL_SIZE * 23, PIXEL_SIZE * 26.5, PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )
        DISPLAYSURF.blit( ShirtIcon, ( PIXEL_SIZE * 22, PIXEL_SIZE * 31, PIXEL_SIZE * 5, PIXEL_SIZE * 3 ) )
        DISPLAYSURF.blit( PantsIcon, ( PIXEL_SIZE * 23, PIXEL_SIZE * 35, PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )
        DISPLAYSURF.blit( ColourIcon, ( PIXEL_SIZE * 43.5, PIXEL_SIZE * 27, PIXEL_SIZE * 3, PIXEL_SIZE * 3 ) )

            # Render the label for the difficulty
        DISPLAYSURF.blit( DifficultyLabel, ( SCREEN_WIDTH / 3 * 2 - DifficultyLabel.get_rect().size[ 0 ] / 2 - int ( PIXEL_SIZE * 1.5 ), PIXEL_SIZE * 5 ) )


            # Render the mouse
        DISPLAYSURF.blit( MouseIMG, ( pygame.mouse.get_pos()[ 0 ], pygame.mouse.get_pos()[ 1 ], MOUSE_SIZE, MOUSE_SIZE ) )



            # Update the screen
        pygame.display.update()














def CheckCollision( Tiles, aPlayer ):

        # Check every tile to see if the player is touching it
    for i in Tiles:

            # If the player is touching the tile, check if the tile is impassable
        if i.GetCollision( aPlayer.x, aPlayer.y, aPlayer.w, aPlayer.h ):

                # The tile is impassable, return that there has been a collision
            if i.BlocksPlayer:
                return True

                # Otherwise, return that there was no collision
            else:
                return False

        # If the character is not on a tile, things are probably very wrong... But return that there a collision anyway
    return True

def CheckMouseOver( x, y, w, h ):
    return not  ( x > pygame.mouse.get_pos()[ 0 ]     or
                  x + w < pygame.mouse.get_pos()[ 0 ]   or
                  y > pygame.mouse.get_pos()[ 1 ]     or
                  y + h < pygame.mouse.get_pos()[ 1 ] )





def TutorialShop( P1 ):
    global SONG_FINISHED

        # List of tips to give through the shopping trip
    Tips = [
        "This is a SHOP and the man on the right is the shop keeper.",
        "To purchase any of the shopkeeper's wares, click on the item you want to purchase.",
        "Do this with the ring on sale now.",
        "When you purchase an item, money is taken from your money pouch.",
        "Your current money is shown in the top left.",
        "Pay attention to your balance when you purchase the health potion in the shop.",
        "That's it for the shop!",
        "Click on the \'EXIT\' button in the bottom left corner to return to the tutorial map."
        ]

    CurrentTip = 0    # Variable that holds the current tip displayed

    TipFont = pygame.font.SysFont( "luxirb.ttf", 28 )   # Holds the font for the tips
    CostFont = pygame.font.SysFont( "luxirb.ttf", 56 )   # Holds the font for the costs
    Text = []   # Holds the text to be printed on the screen

        # Create the background image
    Background = pygame.image.load( "Assets/Backgrounds/Background_4.png" )
    Background = pygame.transform.scale( Background, ( SCREEN_WIDTH, SCREEN_HEIGHT ) )

        # Create the boxes that hold text / purchasable
    TipBox = pygame.image.load( "Assets/Other/Textbox_2.png" )
    TipBox = pygame.transform.scale( TipBox, ( SCREEN_WIDTH, 100 ) )
    ShopBox = pygame.image.load( "Assets/Other/Textbox_3.png" )
    ShopBox = pygame.transform.scale( ShopBox, ( 200, SCREEN_HEIGHT - 100 ) )

        # List of basic ring types
    RingTypes = [ "Strength", "Speed", "Wisdom" ]

        # Create rectangles for the purchasable's hitbox
    PurchasableItems = [ pygame.Rect( SCREEN_WIDTH - 200, 0, 200, ( SCREEN_HEIGHT - 100 ) / 3 ), pygame.Rect( SCREEN_WIDTH - 200, ( SCREEN_HEIGHT - 100 ) / 3, 200, ( SCREEN_HEIGHT - 100 ) / 3 ), pygame.Rect( SCREEN_WIDTH - 200, ( SCREEN_HEIGHT - 100 ) / 3 * 2, 200, ( SCREEN_HEIGHT - 100 ) ) ]
    ItemImages = [ pygame.image.load( "Assets/Items/Lockpick.png" ), pygame.image.load( "Assets/Items/Ring_" + RingTypes[ P1.p_Class - 1 ] + ".png" ), pygame.image.load( "Assets/Items/Potion_Health.png" ) ]
    ItemCostImages = [ CostFont.render( "5", True, ( 0, 0, 0 ) ), CostFont.render( "30", True, ( 0, 0, 0 ) ), CostFont.render( "20", True, ( 0, 0, 0 ) ) ]
    ItemCosts = [ 5, 30, 20 ]

        # Create the money icon on the top left
    DollarImg = pygame.image.load( "Assets/Other/DollarSign.png" )
    DollarImg = pygame.transform.scale( DollarImg, ( int ( PIXEL_SIZE * 2.5 ), int ( PIXEL_SIZE * 4.5 ) ) )
    CurrentMoneyImg = CostFont.render( str( P1.Gold ), True, ( 0, 0, 0 ) )

        # Create the exit button
    ExitButton = pygame.image.load( "Assets/Buttons/Exit.png" )
    ExitButton = pygame.transform.scale( ExitButton, ( 100, 50 ) )

        # Scale all of the Item images
    for i in range( 0, len ( ItemImages ) ):
        ItemImages[ i ] = pygame.transform.scale( ItemImages[ i ], ( int ( 5 * PIXEL_SIZE ), int ( 5 * PIXEL_SIZE ) ) )



    ToBuy = 0   # Variable for the product that the tutorial wants the player to buy
    TipsUp = True   # Boolean that holds whether tips are being diplayed or not

        # Variables for the merchant's animation
    M_Timer = 0
    M_Frame = 1


    P1.SetPos( BATTLE_X, BATTLE_Y )     # Set the position of the player

        # Main shop loop
    while True:

            # Handle events
        for event in pygame.event.get():

                # If the song finished, replay
            if event.type == SONG_FINISHED:
                pygame.mixer.music.play()

                # If the red X is pressed, exit program
            if event.type == QUIT:

                pygame.quit()
                sys.exit()

                # If the mouse has been pressed, continue tips or buy an item if the correct one is selected
            elif event.type == MOUSEBUTTONDOWN:
                if TipsUp:
                    CurrentTip += 1     # Increment the tip displayed

                        # If the CurrentTip has reached the end of a sentence / statement in tips, hide the tips
                    if CurrentTip == 3:
                        ToBuy = 2
                        TipsUp = False

                    elif CurrentTip == 6:
                        ToBuy = 3
                        TipsUp = False

                    elif CurrentTip == 8:
                        ToBuy = 1
                        TipsUp = False


                elif CheckMouseOver( SCREEN_WIDTH - 100, SCREEN_HEIGHT - 50, 100, 50 ):
                    if ToBuy == 1:
                        return

                elif len( PurchasableItems ) > 1:
                        # If the mouse is over the ring, check if they are meant to purchase them
                    if CheckMouseOver( PurchasableItems[ 1 ].x, PurchasableItems[ 1 ].y, PurchasableItems[ 1 ].w, PurchasableItems[ 1 ].h ):
                        if ToBuy == 2:
                                # Delete the image, cost and hitbox
                            P1.Gold -= ItemCosts[ 1 ]
                            ItemImages.pop( 1 )
                            PurchasableItems.pop( 1 )
                            ItemCosts.pop( 1 )
                            ItemCostImages.pop( 1 )
                            TipsUp = True

                        elif ToBuy == 3:
                                # Delete the image, cost and hitbox
                            P1.Gold -= ItemCosts[ 1 ]
                            ItemImages.pop( 1 )
                            PurchasableItems.pop( 1 )
                            ItemCosts.pop( 1 )
                            ItemCostImages.pop( 1 )
                            TipsUp = True


            # Animate the merchant
        M_Timer += 1
        if M_Timer >= 20:
                # Reset the time and increment frame of animation
            M_Timer = 0
            M_Frame += 1
                # If the frame has exceeded the amount of frames, loop
            if M_Frame >= 3:
                M_Frame = 1

            # Create the merchant's image
        Merchant = pygame.image.load( "Assets/NPCS/Merchant_" + str( M_Frame ) + ".png" )
        Merchant = pygame.transform.scale( Merchant, ( int ( Merchant.get_rect().size[ 0 ] * PIXEL_SIZE ), int ( Merchant.get_rect().size[ 1 ] * PIXEL_SIZE ) ) )


                # Render everything
            # Render the background
        DISPLAYSURF.blit( Background, ( 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT ) )

            # Render the merchant
        DISPLAYSURF.blit( Merchant, ( 500, BATTLE_Y, int ( Merchant.get_rect().size[ 0 ] * PIXEL_SIZE ), int ( Merchant.get_rect().size[ 1 ] * PIXEL_SIZE ) ) )

            # Render the player
        P1.Render( 0 )

            # Render the text boxes
        DISPLAYSURF.blit( ShopBox, ( SCREEN_WIDTH - 200, 0, 200, SCREEN_HEIGHT - 100 ) )
        DISPLAYSURF.blit( TipBox, ( 0, SCREEN_HEIGHT - 100, SCREEN_WIDTH, 100 ) )

            # Render the text if it exists
        if TipsUp:
                # Separate the tip into seperate words
            SplitText = Tips[ CurrentTip ].split()
            ConcStr = ""
                # Clear current text on textbox
            Text.clear()

                # While all words haven't been checked, add words to the text
            for i in SplitText:
                    # Make sure that the line doesn't exceed the length of the textbox
                if len( ConcStr ) + len( i ) > 100:
                        # Add string to the text on the box
                    Text.append( TipFont.render( ConcStr, True, ( 0, 0, 0 ) ) )
                        # Reset ConcStr
                    ConcStr = ""

                    # Add the string to ConcStr
                ConcStr += ( i + " " )

                # Add the final word to the textbox
            Text.append( TipFont.render( ConcStr, True, ( 0, 0, 0 ) ) )

                # Display all the lines of text seperately
            y = SCREEN_HEIGHT - 90
            for i in Text:
                DISPLAYSURF.blit( i, ( 10, y, 280, 280 ) )
                y += 24




            # Render the items for sale     # Render item costs
        for i in range( 0, len( PurchasableItems ) ):

            DISPLAYSURF.blit( ItemImages[ i ], ( PurchasableItems[ i ].x + 10, PurchasableItems[ i ].y + 10, 5 * PIXEL_SIZE, 5 * PIXEL_SIZE  ) )
            DISPLAYSURF.blit( ItemCostImages[ i ], ( PurchasableItems[ i ].x + 100, PurchasableItems[ i ].y + 5 * int ( PIXEL_SIZE / 2 ), 5 * PIXEL_SIZE, 5 * PIXEL_SIZE ) )





            # Update money counter at top left
        CurrentMoneyImg = CostFont.render( str( P1.Gold ), True, ( 0, 0, 0 ) )

            # Render money at top left
        DISPLAYSURF.blit( DollarImg, ( 0, 0, int ( PIXEL_SIZE * 2.5 ), int ( PIXEL_SIZE * 4.5 ) ) )
        DISPLAYSURF.blit( CurrentMoneyImg, ( PIXEL_SIZE * 3, 15 ) )

            # Render exit at bottom right
        DISPLAYSURF.blit( ExitButton, ( SCREEN_WIDTH - 100, SCREEN_HEIGHT - 50, 100, 50 ) )





            # Render the mouse
        DISPLAYSURF.blit( MouseIMG, ( pygame.mouse.get_pos()[ 0 ], pygame.mouse.get_pos()[ 1 ], MOUSE_SIZE, MOUSE_SIZE ) )

            # Update the screen
        pygame.display.update()




BUTTON_W = 300
BUTTON_H = 150

def PrintMenu( menu ):

        # Create the brown boxes that act as buttons for the menu's options
    Buttons = pygame.image.load( "Assets/Other/TextBox_2.png" )
    Buttons = pygame.transform.scale( Buttons, ( BUTTON_W, BUTTON_H ) )

        # Create te font of the words on the buttons
    ButtonFont = pygame.font.SysFont( "luxirb.ttf", int ( BUTTON_H / 3 ) )

        # If the currnet menu showing is ATTACK_ENCOUNTER ( 0 ), then show the ENCOUNTER menu
    if menu == ATTACK_ENCOUNTER:
            # Paste the button onto the screen touching each other
        DISPLAYSURF.blit( Buttons, ( 0,         SCREEN_HEIGHT - BUTTON_H,   BUTTON_W, BUTTON_H ) )

            # Create the ATTACK text to put on the first button
        ATTACK = ButtonFont.render( "ATTACK", False, ( 0, 0, 0 ) )
        DISPLAYSURF.blit( ATTACK, ( BUTTON_W / 2 - ATTACK.get_rect().size[ 0 ] / 2,     SCREEN_HEIGHT - BUTTON_H / 2 - ATTACK.get_rect().size[ 1 ] / 2 ) )






def GetButtonPressed( menu ):
    MouseX = pygame.mouse.get_pos()[ 0 ]
    MouseY = pygame.mouse.get_pos()[ 1 ]

    if menu == ATTACK_ENCOUNTER or menu == ATTACK_MENU:
        if MouseX > 0:
            if MouseX < BUTTON_W:
                if MouseY > SCREEN_HEIGHT - BUTTON_H:
                    return 0





def PrintAwards( Enemy ):
    Box = pygame.image.load( "Assets/Other/TextBox_1.png" )
    Box = pygame.transform.scale( Box, ( int ( SCREEN_WIDTH / 2 ), int ( SCREEN_HEIGHT / 2 ) ) )

    BigFont = pygame.font.SysFont( "luxirb.ttf", 56 )
    SmallFont = pygame.font.SysFont( "luxirb.ttf", 56 )

    GoldEarned = int ( Enemy.damage + Enemy.speed + Enemy.defence + Enemy.health / 20 )
    if GoldEarned <= 0:
        GoldEarned = 1
    XpEarned = int ( GoldEarned / 2 )
    if XpEarned <= 0:
        XpEarned = 1

    BattleComplete = BigFont.render( "BATTLE COMPLETE!", True, ( 0, 0, 0 ) )
    Rewards = SmallFont.render( "Earned " + str( GoldEarned ) + " gold and " + str( XpEarned ) + " xp!", True, ( 0, 0, 0 ) )

    DISPLAYSURF.blit( Box, ( int ( SCREEN_WIDTH / 4 ), int ( SCREEN_HEIGHT / 4 ), int ( SCREEN_WIDTH / 2 ), int ( SCREEN_HEIGHT / 2 ) ) )
    DISPLAYSURF.blit( BattleComplete, ( int ( SCREEN_WIDTH / 2 ) - int ( BattleComplete.get_rect().size[ 0 ] / 2 ), int ( SCREEN_HEIGHT / 2 ) - BattleComplete.get_rect().size[ 1 ] * 2, BattleComplete.get_rect().size[ 0 ], BattleComplete.get_rect().size[ 1 ] ) )
    DISPLAYSURF.blit( Rewards, ( int ( SCREEN_WIDTH / 2 ) - int ( Rewards.get_rect().size[ 0 ] / 2 ), int ( SCREEN_HEIGHT / 2 ), Rewards.get_rect().size[ 0 ], Rewards.get_rect().size[ 1 ] ) )

    return [ GoldEarned, XpEarned ]







def TutorialBattle( P1 ):
    global SONG_FINISHED
    Enemy1 = Enemy( PIG, 2 )    # Create the enemy
    Enemy1.SetPos( PIXEL_SIZE * 45, PIXEL_SIZE * 19 )

    E_Timer = 1000
    E_TurnBar = pygame.Rect( PIXEL_SIZE * 45, PIXEL_SIZE * 17, PIXEL_SIZE * 10, PIXEL_SIZE )

    EnemyAnim = IDLE

    #PIXEL_SIZE = SCREEN_WIDTH / 60  # Constant for the pixel size
    P1.SetPos( PIXEL_SIZE * 10, SCREEN_HEIGHT / 4 )   # Set the player's position
    P_Timer = 1000
    P_TurnBar = pygame.Rect( PIXEL_SIZE * 10, SCREEN_HEIGHT / 4 - PIXEL_SIZE * 2, PIXEL_SIZE * 10, PIXEL_SIZE )


        # Create the boxes that hold text / purchasable
    TipBox = pygame.image.load( "Assets/Other/Textbox_2.png" )
    TipBox = pygame.transform.scale( TipBox, ( SCREEN_WIDTH, 100 ) )

        # List of tips to give through the battle
    Tips = [
        "This is a battle encounter.",
        "Here you and your foe will take turns in attacking each other.",
        "Your turn will begin when the purple bar above your head dissapears.",
        "It's your turn! During your turn you will pick an opportunity to attack!",
        "So click the ATTACK button to continue...",
        "Well done, you defeated the pig and earned some gold and xp!",
        "Gold can be spent at shops and gaining Xp will lead to a level up!",
        "Leveling up will allow you to learn new attacks, actions and overall become a stronger character.",
        "This is it for the battle tutorial, but ingame I encourage you to experiment with different items and actions.",
        "You will now be sent to the actual game. Good Luck!",
        ""
        ]



    TipFont = pygame.font.SysFont( "luxirb.ttf", 28 )   # Holds the font for the tips
    TipsUp = True   # Holds whether the tips are onscreen
    CurrentTip = 0  # Holds the current tip
    Text = []   # Holds the text to be printed on the screen

        # Holds whether someone's turn is in progress
    PlayerTurn = False
    EnemyTurn = False
    Pause4Effect = 0

        # Holds whether someone is attacking
    PlayerAttacking = False
    EnemyAttacking = False
    MenuTips = False    # Holds whether tips have already been displayed during the menu
    CollectedLoot = False    # Holds whether rewards have been taken yet


    ButtonPressed = None    # Holds what button has been pressed
    CurrentMenu = ATTACK_ENCOUNTER # Holds the menu that the player is on



        # Load the black background
    Background = pygame.image.load( "Assets/Backgrounds/Background_4.png" )
    Background = pygame.transform.scale( Background, ( SCREEN_WIDTH, SCREEN_HEIGHT ) )

        # Main battle loop
    while True:
        for event in pygame.event.get():
                # If the song finished, replay
            if event.type == SONG_FINISHED:
                pygame.mixer.music.play()

            elif event.type == QUIT:
                pygame.quit()
                sys.exit()

            elif event.type == MOUSEBUTTONDOWN:
                if TipsUp:
                    CurrentTip += 1
                    if CurrentTip == 3 or CurrentTip == 5 or CurrentTip == 10:
                        TipsUp = False

                elif Enemy1.health <= 0:
                    return

                elif PlayerTurn:
                    ButtonPressed = GetButtonPressed( CurrentMenu )
                    if ButtonPressed == 0 and CurrentMenu == ATTACK_ENCOUNTER and not MenuTips:
                        TipsUp = True


            # Advance timers / attack if tips aren't up
        if not TipsUp and not PlayerTurn and not EnemyTurn:
            P_Timer -= P1.speed
            P_TurnBar.w = int( P_Timer / 100 ) * PIXEL_SIZE
            if P_Timer <= 0:
                PlayerTurn = True
                P_Timer += 1000
                if not MenuTips:
                    TipsUp = True

            else:
                E_Timer -= Enemy1.speed
                E_TurnBar.w = int( E_Timer / 100 ) * PIXEL_SIZE
                if E_Timer <= 0:
                    EnemyTurn = True
                    E_Timer += 1000




            # React to button presses
        if PlayerTurn:
            if CurrentMenu == ATTACK_ENCOUNTER:
                if ButtonPressed == 0:
                    PlayerAttacking = True
                    P1.SetPos( PIXEL_SIZE * 30, PIXEL_SIZE * 1 )




                # Render everything
            # Render the Background
        DISPLAYSURF.blit( Background, ( 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT ) )

            # Render the enemy
        if Enemy1.health > 0:
            Enemy1.Render( EnemyAnim, P1 )

            # Render the player
        if PlayerAttacking:
            P1.Render( 1, Enemy1, ButtonPressed )
            if P1.Attacked:
                Pause4Effect += 1
                if Pause4Effect >= 15:
                    if not MenuTips:
                        TipsUp = True
                        MenuTips = True
                    PlayerAttacking = False
                    PlayerTurn = False
                    P1.SetPos( PIXEL_SIZE * 10, SCREEN_HEIGHT / 4 )
                    Pause4Effect = 0
                    CurrentMenu = ATTACK_ENCOUNTER
                    ButtonPressed = None
        else:
            P1.Render( IDLE )

            # Render turn bars
        if not PlayerTurn and not EnemyTurn:
            pygame.draw.rect( DISPLAYSURF, ( 255, 0 , 255 ), E_TurnBar )
            pygame.draw.rect( DISPLAYSURF, ( 255, 0 , 255 ), P_TurnBar )

            # Render HP bars
        if not PlayerAttacking:
            pygame.draw.rect( DISPLAYSURF, ( 255, 0, 0 ), ( PIXEL_SIZE * 10, SCREEN_HEIGHT / 4 - int ( PIXEL_SIZE * 3.5 ), int ( P1.health / 10 ) * PIXEL_SIZE, PIXEL_SIZE ) )
        if not EnemyAttacking and Enemy1.health > 0:
            pygame.draw.rect( DISPLAYSURF, ( 255, 0, 0 ), ( PIXEL_SIZE * 45, int ( PIXEL_SIZE * 15.5 ), int ( Enemy1.health / 10 ) * PIXEL_SIZE, PIXEL_SIZE ) )

            # Render menus
        if PlayerTurn and not PlayerAttacking:
            PrintMenu( CurrentMenu )



            # Check if the enemy is dead
        if Enemy1.health <= 0:
            Awards = PrintAwards( Enemy1 )
            if not CollectedLoot:
                TipsUp = True
                CollectedLoot = True


            # Render the tip box
        if TipsUp:
            DISPLAYSURF.blit( TipBox, ( 0, SCREEN_HEIGHT - 100, SCREEN_WIDTH, 100 ) )




            # Render the tips
        if TipsUp:
                # Separate the tip into seperate words
            SplitText = Tips[ CurrentTip ].split()
            ConcStr = ""
                # Clear current text on textbox
            Text.clear()

                # While all words haven't been checked, add words to the text
            for i in SplitText:
                    # Make sure that the line doesn't exceed the length of the textbox
                if len( ConcStr ) + len( i ) > 100:
                        # Add string to the text on the box
                    Text.append( TipFont.render( ConcStr, True, ( 0, 0, 0 ) ) )
                        # Reset ConcStr
                    ConcStr = ""

                    # Add the string to ConcStr
                ConcStr += ( i + " " )

                # Add the final word to the textbox
            Text.append( TipFont.render( ConcStr, True, ( 0, 0, 0 ) ) )

                # Display all the lines of text seperately
            y = SCREEN_HEIGHT - 90
            for i in Text:
                DISPLAYSURF.blit( i, ( 10, y, 280, 280 ) )
                y += 24


            # Render the mouse
        DISPLAYSURF.blit( MouseIMG, ( pygame.mouse.get_pos()[ 0 ], pygame.mouse.get_pos()[ 1 ], MOUSE_SIZE, MOUSE_SIZE ) )


            # Update the screen
        pygame.display.update()





def Tutorial( P1 ):
    global SONG_FINISHED

        # Sets the writing at the top of the window
    pygame.display.set_caption( "TUTORIAL" )

        # Load the black background
    Background = pygame.image.load( "Assets/Backgrounds/Background_3.png" )
    Background = pygame.transform.scale( Background, ( SCREEN_WIDTH, SCREEN_HEIGHT ) )

        # Create the box to put all of the text in
    TipBox = pygame.image.load( "Assets/Other/TextBox_1.png" )
    TipBox = pygame.transform.scale( TipBox, ( 300, 300 ) )

        # Create a list for all of the tips
    Tips = [
        "Here is the world map. <Click to advance tips>",
        "Your token should be on the southmost tile, it shows you your position on the map.",
        "To move the token around the map press WASD or the arrow keys.",
        "Move to the end of that corridor to continue. <Click to close textbox and start moving>",
        "On the map, you will find tiles that are more dangerous to go through. In this case the red tile is a dangerous tile.",
        "Use WASD or arrow keys to navigate around the red tile.",
        "During your adventure you will battle monsters and meet, trade or party with friendly NPCs",
        "Above on the green tile is a SHOP encounter.",
        "Move to that tile to continue.",
        "Above on the red tile is a BATTLE encounter.",
        "Move to that tile to continue.",
        "FINAL TIP! When health is lost in a battle, you remain damaged for future fights!",
        "Rest up at a villiage or level up to return to full health! No go on adventurer, you are needed elsewhere!",
        "No! You have to navigate AROUND the red tile!",
        "Lets try that again shall we..."
        ]

        # Holds the font for the tips
    TipFont = pygame.font.SysFont( "luxirb.ttf", 28 )

        # Holds current text on screen
    CurrentTip = 0
    RedTip = 13
    Text = []

        # Holds the places where tips are triggered
    TriggerTiles = deque()
    TriggerTiles.append( ( 420, 330 ) )
    TriggerTiles.append( ( 420, 240 ) )

        # Holds the actual text that appears on screen
    Lines = []

        # Boolean variables
    HelpUp = True
    GetOffTheRed = False
    BeenShooping = False
    BeenBattling = False

        # Create an array for the tiles
    Tiles = []

        # Constant for the tile size
    TILE_SIZE = 30

        # Set the starting position of the player
    P1.SetPos( int ( SCREEN_WIDTH / TILE_SIZE / 2 - 1 ) * TILE_SIZE, TILE_SIZE * 16 )

        # Set the position of the first tile
    x = int ( SCREEN_WIDTH / TILE_SIZE / 2 - 1 ) * TILE_SIZE
    y = TILE_SIZE * 4

        # Load the tiles according to Tutorial list
    for i in TUTORIAL_LEVEL:

            # If the tile is a wall, ignore it, off the map counts as a wall
        if i != 1:
                # Add next tile
            Tiles.append( Tile( x, y, TILE_SIZE, TILE_SIZE, "Assets/Tiles/Tutorial Tiles/Tile_" + str( i + 1 ) + ".png", False, ( i == 3 ), ( i == 2 ) ) )

            # Correct X and Y positions for the next tile
        if x == int ( SCREEN_WIDTH / TILE_SIZE / 2 - 1 ) * TILE_SIZE:
            x = int ( SCREEN_WIDTH / TILE_SIZE / 2 ) * TILE_SIZE

        else:
            x = int ( SCREEN_WIDTH / TILE_SIZE / 2 - 1 ) * TILE_SIZE
            y += TILE_SIZE


        # Main tutorial loop
    while True:

            # If the tip box isn't visible, controls move the player's token
        if not HelpUp and not GetOffTheRed:
                # Handle events
            for event in pygame.event.get():

                    # If the song finished, replay
                if event.type == SONG_FINISHED:
                    pygame.mixer.music.play()

                    # If the player quits, exit game
                elif event.type == QUIT:

                    pygame.quit()
                    sys.exit()

#                elif event.type == MOUSEBUTTONDOWN:

                    # Get keypresses
                elif event.type == KEYDOWN:

                        # If UP or W is pressed, move the player's token up a tile
                    if event.key == K_UP or event.key == K_w:
                        P1.SetPos( P1.x, P1.y - TILE_SIZE )

                            # If the player has hit an impassable tile, move back
                        if CheckCollision( Tiles, P1 ):
                            P1.SetPos( P1.x, P1.y + TILE_SIZE )

                        # If DOWN or S is pressed, move the player's token down a tile
                    elif event.key == K_DOWN or event.key == K_s:
                        P1.SetPos( P1.x, P1.y + TILE_SIZE )

                            # If the player has hit an impassable tile, move back
                        if CheckCollision( Tiles, P1 ):
                            P1.SetPos( P1.x, P1.y - TILE_SIZE )

                        # If LEFT or a is pressed, move the player's token left a tile
                    elif event.key == K_LEFT or event.key == K_a:
                        P1.SetPos( P1.x - TILE_SIZE, P1.y )

                            # If the player has hit an impassable tile, move back
                        if CheckCollision( Tiles, P1 ):
                            P1.SetPos( P1.x + TILE_SIZE, P1.y )

                        # If RIGHT or d is pressed, move the player's token right a tile
                    elif event.key == K_RIGHT or event.key == K_d:
                        P1.SetPos( P1.x + TILE_SIZE, P1.y )

                            # If the player has hit an impassable tile, move back
                        if CheckCollision( Tiles, P1 ):
                            P1.SetPos( P1.x - TILE_SIZE, P1.y )


            # If the tip that tells you not to go on the red tile pops up, do not touch the CurrentTip variable:
        elif GetOffTheRed:
                # Handle events
            for event in pygame.event.get():

                    # If the song finished, replay
                if event.type == SONG_FINISHED:
                    pygame.mixer.music.play()

                    # If the player clicks the red X, exit the program
                elif event.type == QUIT:

                    pygame.quit()
                    sys.exit()

                    # If the mouse is clicked or enter is pressed then continue to next tip
                elif event.type == MOUSEBUTTONDOWN:
                        # Increment the tip counter
                    RedTip += 1

                        # Exit the tip if the point has been passed
                    if RedTip == 15:
                        RedTip = 13
                        P1.y += TILE_SIZE * 2
                        GetOffTheRed = False


            # If tips are up, mouse continues instructions / closes tip
        else:

                # Handle events
            for event in pygame.event.get():

                    # If the song finished, replay
                if event.type == SONG_FINISHED:
                    pygame.mixer.music.play()

                    # If the player clicks the red X, exit the program
                elif event.type == QUIT:

                    pygame.quit()
                    sys.exit()

                    # If the mouse is clicked or enter is pressed then continue to next tip
                elif event.type == MOUSEBUTTONDOWN:
                        # Increment the tip counter
                    CurrentTip += 1

                        # Exit the tip if the point has been passed
                    if CurrentTip == 4 or CurrentTip == 6 or CurrentTip == 9 or CurrentTip == 11:
                        HelpUp = False

                    elif CurrentTip == 13:
                        return MAIN_MAP



                # Render everything
            # Render the background
        DISPLAYSURF.blit( Background, ( 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT ) )

            # Render the tiles
        for i in Tiles:
            i.Render()

            # Render the player
        P1.RenderMap()

            # Render tips
        if HelpUp:
            DISPLAYSURF.blit( TipBox, ( 0, SCREEN_HEIGHT - 300, 300, 300 ) )

                # Separate the tip into seperate words
            SplitText = Tips[ CurrentTip ].split()
            ConcStr = ""
                # Clear current text on textbox
            Text.clear()

                # While all words haven't been checked, add words to the text
            for i in SplitText:
                    # Make sure that the line doesn't exceed the length of the textbox
                if len( ConcStr ) + len( i ) > 25:
                        # Add string to the text on the box
                    Text.append( TipFont.render( ConcStr, True, ( 0, 0, 0 ) ) )
                        # Reset ConcStr
                    ConcStr = ""

                    # Add the string to ConcStr
                ConcStr += ( i + " " )

                # Add the final word to the textbox
            Text.append( TipFont.render( ConcStr, True, ( 0, 0, 0 ) ) )

                # Display all the lines of text seperately
            y = SCREEN_HEIGHT - 290
            for i in Text:
                DISPLAYSURF.blit( i, ( 10, y, 280, 280 ) )
                y += 24

            # IF the player has stepped on the avoidable red tile, tell them off and send them back to retry
        elif GetOffTheRed:
                # Render textbox
            DISPLAYSURF.blit( TipBox, ( 0, SCREEN_HEIGHT - 300, 300, 300 ) )

                # Split the tip into words
            SplitText = Tips[ RedTip ].split()
            ConcStr = ""
                # Clear current text
            Text.clear()

                # While all words haven't been checked, add words to text list
            for i in SplitText:
                    # Make sure the line doesn't exceed the length of the box
                if len( ConcStr ) + len( i ) > 25:
                        # Add word to the text list
                    Text.append( TipFont.render( ConcStr, True, ( 0, 0, 0 ) ) )
                    ConcStr = ""

                    # Add word to ConcStr string
                ConcStr += ( i + " " )

                # Add the final word to the text list
            Text.append( TipFont.render( ConcStr, True, ( 0, 0, 0 ) ) )

                # Display all lines of text seperately
            y = SCREEN_HEIGHT - 290
            for i in Text:
                DISPLAYSURF.blit( i, ( 10, y, 280, 280 ) )
                y += 24


            # Render the mouse
        DISPLAYSURF.blit( MouseIMG, ( pygame.mouse.get_pos()[ 0 ], pygame.mouse.get_pos()[ 1 ], MOUSE_SIZE, MOUSE_SIZE ) )



            # Update the screen
        pygame.display.update()



        # Makes sure we don't access a non-existant part of the list
        if len( TriggerTiles ) > 0:
                # Checks if the player has touched the next trigger tile
            if TriggerTiles[ 0 ] == ( P1.x, P1.y ):

                    # Remove trigger tile from list and activate the next tip
                TriggerTiles.popleft()
                HelpUp = True

        # If the player is touching the red tile that they were told to avoid. Tell them what they did wrong and set there position down two tiles
        if P1.x == 420 and P1.y == 270:
            GetOffTheRed = True

        # If the player is touching a tile that triggers an encounter, trigger encounter
        if P1.y == 180 and not BeenShooping:
            TutorialShop( P1 )
            BeenShooping = True
            HelpUp = True
            P1.SetPos( 420, 180 )

        elif P1.y == 120 and not BeenBattling:
            pygame.mixer.music.stop()
            pygame.mixer.music.load( "Music/wav/EventTrack.wav" )
            TutorialBattle( P1 )
#            pygame.mixer.music.load( "Music/wav/MapTrack.wav" )
            HelpUp = True
            BeenBattling = True
            P1.SetPos( 420, 120 )







            # IS NOT IN THE GAME
def CursedEvent( P1 ):
    Background = pygame.image.load( "Assets/Backgrounds/Cursed_Background.png" )
    Background = pygame.transform.scale( Background, ( SCREEN_WIDTH, SCREEN_HEIGHT ) )

        # Set the player's position
    P1.SetPos( BATTLE_X, BATTLE_Y )

    while True:

            # Handle events
        for event in pygame.event.get():
                # If the red X is clicked, exit the program
            if event.type == QUIT:

                pygame.quit()
                sys.exit()


                # Render everything
            # Render the background
        DISPLAYSURF.blit( Background, ( 0, 0 ) )

            # Render the player
        P1.Render( IDLE )

            # Update the screen
        pygame.display.update()


            # IS NOT IN THE GAME
def WitchEvent( P1 ):
    Background = pygame.image.load( "Assets/Backgrounds/Cursed_Background.png" )
    Background = pygame.transform.scale( Background, ( SCREEN_WIDTH, SCREEN_HEIGHT ) )

        # Set the player's position
    P1.SetPos( BATTLE_X, BATTLE_Y )

    while True:

            # Handle events
        for event in pygame.event.get():
                # If the red X is clicked, exit the program
            if event.type == QUIT:

                pygame.quit()
                sys.exit()


                # Render everything
            # Render the background
        DISPLAYSURF.blit( Background, ( 0, 0 ) )

            # Render the player
        P1.Render( IDLE )

            # Update the screen
        pygame.display.update()


            # Gives the player a random item, or an item passed into the function
def ItemEvent( P1, Biome, Item = None ):
    global FPS
    global SONG_FINISHED

        # FPS Clock
    fpsClock = pygame.time.Clock()

        # Load the background image depending on the tile's biome
    Background = pygame.image.load( "Assets/Backgrounds/Background_" + str( Biome + 4 ) + ".png" )
        # Stretch to fill the screen
    Background = pygame.transform.scale( Background, ( SCREEN_WIDTH, SCREEN_HEIGHT ) )

        # Create a yellow background for the item name
    YellowBack = pygame.image.load( "Assets/Character Creation Icons/Colour/Colour_4.png" )

        # Create the item that the player found
    Found = 0
    ItemNo = 99999999
    if Item == None:
        ItemNo = random.randint( 0, len( Items ) - 1 )
        Found = Items[ ItemNo ]
    else:
        Found = str( Item )

        # Load the item as displayable text
    ItemFont = pygame.font.SysFont( "luxirb.ttf", 28 )
    ItemText = ItemFont.render( "You found a " + Found, True, ( 0, 0, 0 ) )

        # Scale the yellow rectangle to fit the text
    YellowBack = pygame.transform.scale( YellowBack, ( ItemText.get_rect().size[ 0 ] + 10, ItemText.get_rect().size[ 1 ] + 10 ) )

        # Add item to the player's inventory
    P1.Items.append( Found )

        # Give stat bonuses depending on the item
    if ItemNo <= 4:
        P1.strength += 3

    elif ItemNo <= 9:
        P1.strength += 6

    elif ItemNo <= 14:
        P1.defence += 3

    elif ItemNo <= 19:
        P1.defence += 6

    elif ItemNo <= 24:
        P1.speed += 3

    elif ItemNo <= 29:
        P1.speed += 6

    elif ItemNo <= 34:
        P1.wisdom += 3

    elif ItemNo <= 39:
        P1.wisdom += 6


        # Set the player's position
    P1.SetPos( BATTLE_X, BATTLE_Y )

        # Main Loop
    while True:

            # Handle events
        for event in pygame.event.get():

                # If the song finished, repeat it
            if event.type == SONG_FINISHED:
                pygame.mixer.music.play()

                # If the red X is clicked, exit the program
            elif event.type == QUIT:

                pygame.quit()
                sys.exit()

                # If the mouse is clicked, return to the map
            elif event.type == MOUSEBUTTONDOWN:
                return


                # Render everything
            # Render the background
        DISPLAYSURF.blit( Background, ( 0, 0 ) )

            # Render the player
        P1.Render( IDLE )

            # Render yellow rectangle
        DISPLAYSURF.blit( YellowBack, ( SCREEN_WIDTH - YellowBack.get_rect().size[ 0 ] - 50, SCREEN_HEIGHT / 2 - YellowBack.get_rect().size[ 1 ] / 2 ) )

            # Render the text
        DISPLAYSURF.blit( ItemText, ( SCREEN_WIDTH - YellowBack.get_rect().size[ 0 ] - 45, SCREEN_HEIGHT / 2 - ItemText.get_rect().size[ 1 ] / 2 ) )

            # Update the screen
        pygame.display.update()

            # Control framerate
        fpsClock.tick( FPS )


            # Creates an event where the player can buy items for the money they have collected
def ShopEvent( P1, Biome ):
    global FPS
    global SONG_FINISHED

        # FPS Clock
    fpsClock = pygame.time.Clock()

    Background = pygame.image.load( "Assets/Backgrounds/Background_" + str( Biome + 4 ) + ".png" )  # Load the background depending on the biome
    Background = pygame.transform.scale( Background, ( SCREEN_WIDTH, SCREEN_HEIGHT ) )              # Stretch the background to fill the screen

    CostFont = pygame.font.SysFont( "luxirb.ttf", int ( PIXEL_SIZE * 6 ) )      # Load a font for the displayed prices

    P1.SetPos( BATTLE_X, BATTLE_Y )   # Set the player's position

        # Create the merchant
    Merchant = [ pygame.image.load( "Assets/NPCS/Merchant_1.png" ), pygame.image.load( "Assets/NPCS/Merchant_2.png" ) ]     # Load the merchant's idle animation
    Merchant[ 0 ] = pygame.transform.scale( Merchant[ 0 ], ( int ( Merchant[ 0 ].get_rect().size[ 0 ] * PIXEL_SIZE ), int ( Merchant[ 0 ].get_rect().size[ 1 ] * PIXEL_SIZE ) ) )   # Stretch out the first frame of the merchant's idle animation
    Merchant[ 1 ] = pygame.transform.scale( Merchant[ 1 ], ( int ( Merchant[ 1 ].get_rect().size[ 0 ] * PIXEL_SIZE ), int ( Merchant[ 1 ].get_rect().size[ 1 ] * PIXEL_SIZE ) ) )   # Stretch out the second frame of the merchant's idle animation
    M_IdleFrame = 0     # Holds the frame of the merchant's idle animation
    M_Timer = 20        # Timer to slow down the idle animation

        # Create a box to put behind the items on sale
    ShopBox = pygame.image.load( "Assets/Other/Textbox_3.png" )
    ShopBox = pygame.transform.scale( ShopBox, ( 200, SCREEN_HEIGHT ) )

    RandomItems  = [ random.randint( 0, len( Items ) - 1 ), random.randint( 0, len( Items ) - 1 ), random.randint( 0, len( Items ) - 1 ) ]      # Select three random items to sell
    ItemHitboxes = [ pygame.Rect( SCREEN_WIDTH - 200, SCREEN_HEIGHT / 8, 200, 120 ), pygame.Rect( SCREEN_WIDTH - 200, SCREEN_HEIGHT / 8 * 3, 200, 120 ), pygame.Rect( SCREEN_WIDTH - 200, SCREEN_HEIGHT / 8 * 5, 200, 120 ) ]   # Create rectangles for the purchasable's hitbox

    ItemImages      = [ pygame.image.load( "Assets/Items/" + Items[ RandomItems[ 0 ] ] + ".png" ), pygame.image.load( "Assets/Items/" + Items[ RandomItems[ 1 ] ] + ".png" ), pygame.image.load( "Assets/Items/" + Items[ RandomItems[ 2 ] ] + ".png" ) ]      # Load the images of each random item
    ItemImages[ 0 ] = pygame.transform.scale( ItemImages[ 0 ], ( int ( 8 * PIXEL_SIZE ), int ( 8 * PIXEL_SIZE ) ) )
    ItemImages[ 1 ] = pygame.transform.scale( ItemImages[ 1 ], ( int ( 8 * PIXEL_SIZE ), int ( 8 * PIXEL_SIZE ) ) )
    ItemImages[ 2 ] = pygame.transform.scale( ItemImages[ 2 ], ( int ( 8 * PIXEL_SIZE ), int ( 8 * PIXEL_SIZE ) ) )

        # Find the cost of each random item
    ItemCosts = []      # Holds item costs
    ItemTypes = []      # Holds what each item does
        # Iterate through all randomly selected items
    for i in RandomItems:

            # Find where the number is in it's group of 5
        DivFive = i / 5                         # Holds the position in group ( decimal ) and group no ( whole number )
        IntDiv = int ( DivFive )                # Just holds the group number
        JustFloat = DivFive - IntDiv            # Takes the group no. away from the position and group to find the position in the group
        SpotInGroup = int ( JustFloat * 10 )    # Multiply the position in the group by ten to make it a whole number

        ItemTypes.append( IntDiv )      # The group number determines what the item does

            # Find if the item is a good or bad item
        # Divide i by five to make each group of five fall into 1 number
        if int ( i / 5 ) % 2 == 0:  # Check if the number is even, if it is, it is one of the more expensive items
            ItemCosts.append( 30  + SpotInGroup * 4 + random.randint( 10, 30 ) - int ( P1.wisdom / 3 ) )      # Calculate the item's cost
        else:
            ItemCosts.append( 15 + SpotInGroup * 3 + random.randint( 5, 40 ) - int ( P1.wisdom / 3 ) )      # Calculate the item's cost

        if ItemCosts[ len( ItemCosts ) - 1 ] <= 0:
            ItemCosts[ len( ItemCosts ) - 1 ] = 1


    ItemCostImages      = [ CostFont.render( str( ItemCosts[ 0 ] ), True, ( 0, 0, 0 ) ), CostFont.render( str( ItemCosts[ 1 ] ), True, ( 0, 0, 0 ) ), CostFont.render( str( ItemCosts[ 2 ] ), True, ( 0, 0, 0 ) ) ]     # Create the numbers to display the cost of each item

        # Create the money icon on the top left
    DollarImg = pygame.image.load( "Assets/Other/DollarSign.png" )
    DollarImg = pygame.transform.scale( DollarImg, ( int ( PIXEL_SIZE * 2.5 ), int ( PIXEL_SIZE * 4.5 ) ) )

        # Create the exit button
    ExitButton = pygame.image.load( "Assets/Buttons/Exit.png" )
    ExitButton = pygame.transform.scale( ExitButton, ( 100, 50 ) )

        # Main shop loop
    while True:

            # Handle events
        for event in pygame.event.get():

                # If the song finished, repeat it
            if event.type == SONG_FINISHED:
                pygame.mixer.music.play()

                # If the red X is clicked, exit the program
            elif event.type == QUIT:

                pygame.quit()
                sys.exit()

                # If the mouse is clicked, check if any buttons were clicked
            elif event.type == MOUSEBUTTONDOWN:

                    # If the exit button is clicked, return the the main map
                if CheckMouseOver( SCREEN_WIDTH - 100, SCREEN_HEIGHT - 50, 100, 50 ):
                    return
                    # If the exit button wasn't clicked and there are items on sale, check if any where bought
                elif len( RandomItems ) >= 1:
                    for i in range( 0, len( ItemHitboxes ) ):
                        if CheckMouseOver( ItemHitboxes[ i ].x, ItemHitboxes[ i ].y, ItemHitboxes[ i ].w, ItemHitboxes[ i ].h ) and P1.Gold >= ItemCosts[ i ]:
                            P1.Gold -= ItemCosts[ i ]
                            P1.Items.append( RandomItems[ i ] )
                                # Apply the item stat bonuses to the player
                            if ItemTypes[ i ] == 0:
                                P1.strength += 3
                            elif ItemTypes[ i ] == 1:
                                P1.strength += 6
                            elif ItemTypes[ i ] == 2:
                                P1.defence += 3
                            elif ItemTypes[ i ] == 3:
                                P1.defence += 6
                            elif ItemTypes[ i ] == 4:
                                P1.speed += 3
                            elif ItemTypes[ i ] == 5:
                                P1.speed += 6
                            elif ItemTypes[ i ] == 6:
                                P1.wisdom += 3
                            elif ItemTypes[ i ] == 7:
                                P1.wisdom += 6

                            RandomItems.pop( i )
                            ItemHitboxes.pop()
                            ItemCosts.pop( i )
                            ItemImages.pop( i )
                            ItemCostImages.pop( i )
                            ItemTypes.pop( i )
                            break


            # Render everything
        DISPLAYSURF.blit( Background, ( 0, 0 ) )    # Render the background
        P1.Render( IDLE )                            # Render the player
        DISPLAYSURF.blit( Merchant[ M_IdleFrame ], ( 500, BATTLE_Y ) )    # Render the merchant

            # Update the merchant's idle frame
        M_Timer -= 1    # Advance the merchant's timer
        if M_Timer <= 0:    # If the timer has reached 0...
            M_Timer = 20    # ... Reset the timer ...
            M_IdleFrame += 1# ... and advance the idle animation
                # If the idle frame has reached the end of the animation...
            if M_IdleFrame >= 2:
                M_IdleFrame = 0 # ... Set frame to 0 to allow the animation to loop


        DISPLAYSURF.blit( ShopBox, ( SCREEN_WIDTH - 200, 0 ) )    # Render the box

            # Render the items + prices
        for i in range( 0, len( ItemImages ) ):
            DISPLAYSURF.blit( ItemImages[ i ], ( SCREEN_WIDTH - 200, SCREEN_HEIGHT / 8 + ( SCREEN_HEIGHT / 4 * i ) ) )
            DISPLAYSURF.blit( ItemCostImages[ i ], ( SCREEN_WIDTH - 70, SCREEN_HEIGHT / 8 + PIXEL_SIZE * 2 + ( SCREEN_HEIGHT / 4 * i ) ) )

            # Render a dollar sign in the upper left corner
        DISPLAYSURF.blit( DollarImg, ( 0, 0 ) )

            # Render the player's current money
        CurrentMoneyImg = CostFont.render( str( P1.Gold ), True, ( 0, 0, 0 ) )
        DISPLAYSURF.blit( CurrentMoneyImg, ( PIXEL_SIZE * 3, PIXEL_SIZE / 2 ) )

            # Render the exit button
        DISPLAYSURF.blit( ExitButton, ( SCREEN_WIDTH - 100, SCREEN_HEIGHT - 50 ) )

            # Render the mouse
        DISPLAYSURF.blit( MouseIMG, ( pygame.mouse.get_pos()[ 0 ], pygame.mouse.get_pos()[ 1 ] ) )

            # Update the screen
        pygame.display.update()

            # Control framerate
        fpsClock.tick( FPS )

            # Fades out of the main map into the battle event ( NOT IN THE GAME )
def BattleTransition():
        # Create a black screen
    BlackBack = pygame.Surface( ( SCREEN_WIDTH, SCREEN_HEIGHT ) )
    BlackBack.fill( ( 0, 0, 0 ) )
    BlackBack.set_alpha( 0 )

        # Create image of the swords

        # Repeat until the BlackBack is full visible
    while BlackBack.get_alpha() < 255:
        BlackBack.set_alpha( BlackBack.get_alpha() + 1 )    # Increase alpha

        DISPLAYSURF.blit( BlackBack, ( 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT ) )     # Copy the surface to the screen

            # Update the screen
        pygame.display.update()




            # Creates an event where the player fights an enemy ( difficulty is determined by the amount of battles faught )
def BattleEvent( P1, Biome ):
        # Declare global difficulty
    global Difficulty, FPS

        # FPS Clock
    fpsClock = pygame.time.Clock()

        # Variable for the player's height
    PlayerHeight = PIXEL_SIZE * 18

        # Check if difficulty is 0
    if Difficulty <= 0:
        Difficulty = 1  # If difficulty is 0, set it to 1

    BiggestEnemy = 0    # Holds the number of the most dangerous enemy the player can encounter

        # If the most dangerous enemy calculated by difficulty is non - existant...
    if int ( Difficulty / 10 ) > len ( MonsterStats ) - 3:
        BiggestEnemy = len ( MonsterStats ) - 3 # ... Make the most dangerous monster the player can encounter be the most dangerous monster in the current game


    else:       # If the most dangerous enemy calculated by difficulty does exist...
        BiggestEnemy = int ( Difficulty / 10 )  # ... Set the most dangerous enemy using the current difficulty

    EnemyNo = random.randint( 0, BiggestEnemy )
    Enemy1 = Enemy( EnemyNo, Difficulty )     # Create the enemy
    Enemy1.SetPos( PIXEL_SIZE * 45, BATTLE_Y + PlayerHeight - Enemy1.image.get_rect().size[ 1 ] )       # Set the enemy's position

    E_Timer = 1000                                                                              # Timer for the enemy's turn
    E_TurnBar = pygame.Rect( PIXEL_SIZE * 45, BATTLE_Y + PlayerHeight - Enemy1.image.get_rect().size[ 1 ] - PIXEL_SIZE, PIXEL_SIZE * 10, PIXEL_SIZE )    # Bar to show the remainder of the enemy's timer
    EnemyAnim = IDLE                                                                            # The current animation plated by the enemy

    P1.SetPos( BATTLE_X, BATTLE_Y )   # Set the player's position
    P_Timer = 1000                                    # Timer for the player's turn
    P_TurnBar = pygame.Rect( PIXEL_SIZE * 10, BATTLE_Y - PIXEL_SIZE * 2, PIXEL_SIZE * 10, PIXEL_SIZE )     # Bar to show the remainder of the player's timer



    PlayerTurn = False          # Holds whether the player's turn is in progress
    EnemyTurn = False           # Holds whether the enemy's turn is in progress
    PlayerAttacking = False     # Holds whether the player is attacking
    EnemyAttacking = False      # Holds whether the enemy is attacking
    CollectedLoot = False        # Holds whether rewards have been taken yet


    Pause4Effect = 0                # A small timer that delays the return to the "Waiting" faze
    ButtonPressed = None            # Holds what button has been pressed
    CurrentMenu = ATTACK_ENCOUNTER  # Holds the menu that the player is on



    Background = pygame.image.load( "Assets/Backgrounds/Background_" + str( Biome + 4 ) + ".png" )  # Load the background depending on the biome
    Background = pygame.transform.scale( Background, ( SCREEN_WIDTH, SCREEN_HEIGHT ) )              # Stretch the background to fill the screen

        # Load music
    SONG_FINISHED = pygame.USEREVENT + 1
    pygame.mixer.music.load( "Music/wav/EventTrack.wav" )
    pygame.mixer.music.play()


        # Main battle loop
    while True:

            # Handle events
        for event in pygame.event.get():

            if event.type == SONG_FINISHED:
                pygame.mixer.music.play()

                # If the red X is clicked, quit the program
            elif event.type == QUIT:

                pygame.quit()
                sys.exit()

                # If the mouse is clicked...
            elif event.type == MOUSEBUTTONDOWN:

                    # ...check if the rewards are up
                if Enemy1.health <= 0:
                        # STOP THE MUSIC !!!
                    pygame.mixer.music.stop()

                        # Return to the world map
                    return

                    # ...check if it's the player's turn
                elif PlayerTurn:

                        # Find what button the player clicked ( None if they didn't click any )
                    ButtonPressed = GetButtonPressed( CurrentMenu )



            # Check if someone's turn is in progress or if anyone has died / won
        if not PlayerTurn and not EnemyTurn and Enemy1.health > 0 and P1.health > 0:

            P_Timer -= P1.speed                                 # Advance the player's timer
            P_TurnBar.w = int( P_Timer / 100 ) * PIXEL_SIZE     # Update the pink bar depending on the remaning time until the player's turn

                # Check if the player's timer has reached 0
            if P_Timer <= 0:
                PlayerTurn = True   # Start the player's turn
                P_Timer += 1000     # Reset the player's timer

                # If the player's timer has not reached 0
            else:

                E_Timer -= Enemy1.speed                             # Advance the enemy's timer
                E_TurnBar.w = int( E_Timer / 100 ) * PIXEL_SIZE     # Update the pink bar depending on the remaning time until the enemy's turn

                    # Check if the enemy's timer has reached 0
                if E_Timer <= 0:
                    EnemyTurn = True    # Start the enemy's turn
                    E_Timer += 1000     # Reset the enemy's timer




            # Check if the player's turn is in progress
        if PlayerTurn:

                # Check if the current popup menu is the ATTACK_ENCOUNTER menu
            if CurrentMenu == ATTACK_ENCOUNTER:

                    # If the ATTACK button has been pressed...
                if ButtonPressed == 0:
                    PlayerAttacking = True                          # Start the player's attack
                    P1.SetPos( PIXEL_SIZE * 30, PIXEL_SIZE * 1 )    # Set the player's position to melee range

            # Check if the enemy's turn is in progress
        elif EnemyTurn:

                # Randomly choose which attack to use
            AttackNum = random.randint( 1, 3 )
            if AttackNum < 3:
                Enemy1.SetPos( BATTLE_X, BATTLE_Y + PlayerHeight - Enemy1.image.get_rect().size[ 1 ] )       # Set the enemy's position
                EnemyAnim = ATTACK_1    # Set the enemy's animation to it's attack animation

            else:
                EnemyAnim = ATTACK_2

            EnemyTurn = False
            EnemyAttacking = True



                # Render everything
        DISPLAYSURF.blit( Background, ( 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT ) )       # Render the Background



            # Check if the enemy is still alive
        if Enemy1.health > 0:
            if EnemyAttacking:

                    # Check if the enemy has finished their attack
                if Enemy1.Attacked:
                    Pause4Effect += 1   # Advance the "Pause for effect" timer
                    Enemy1.Render( EnemyAnim, P1, MonsterAnimLength[ EnemyNo ][ EnemyAnim ] )

                        # If the enemy has paused of a reasonable amount of time...
                    if Pause4Effect >= 30:

                        EnemyAttacking = False                       # End the enemy's attacking faze
                        EnemyTurn = False                            # End the enemy's turn
                        Enemy1.SetPos( PIXEL_SIZE * 45, BATTLE_Y + PlayerHeight - Enemy1.image.get_rect().size[ 1 ] )       # Set the enemy's position back to normal

                        Pause4Effect = 0                # Reset the "Pause for effect" timer
                else:
                    Enemy1.Render( EnemyAnim, P1 )

            else:
                Enemy1.Render( IDLE, P1 )  # Blit the enemy onto the screen



            # Check if the player is attacking
        if PlayerAttacking:
            P1.Render( 1, Enemy1, ButtonPressed )   # Blit the player onto the screen

                # If the player has finished their attack...
            if P1.Attacked:
                Pause4Effect += 1   # ... advance the "Pause for effect" timer

                    # If the player has paused of a reasonable amount of time...
                if Pause4Effect >= 15:

                    PlayerAttacking = False             # End the player's attacking faze
                    PlayerTurn = False                  # End the player's turn
                    P1.SetPos( BATTLE_X, BATTLE_Y )     # Set the player's position back to normal

                    Pause4Effect = 0                # Reset the "Pause for effect" timer
                    CurrentMenu = ATTACK_ENCOUNTER  # Reset the popup menu
                    ButtonPressed = None            # Reset the button pressed


        else:                   # If the player is not attacking...
            P1.Render( IDLE )   # ... Render the player in the idle animation



            # Make sure that no one's turn is in progress or if anyone has died
        if not PlayerTurn and not PlayerAttacking and not EnemyTurn and not EnemyAttacking and Enemy1.health > 0 and P1.health > 0:
            pygame.draw.rect( DISPLAYSURF, ( 255, 0 , 255 ), E_TurnBar )    # Blit the enemy's remaining turn timer bar onto the screen
            pygame.draw.rect( DISPLAYSURF, ( 255, 0 , 255 ), P_TurnBar )    # Blit the player's remaining turn timer bar onto the screen


            # Make sure the player isn't attacking or anyone has won
        if not PlayerAttacking and Enemy1.health > 0 and P1.health > 0:
                # Draw the player's heath bar onto the screen
            pygame.draw.rect( DISPLAYSURF, ( 255, 0, 0 ), ( PIXEL_SIZE * 10, BATTLE_Y - int( PIXEL_SIZE * 3.5 ), int ( P1.health / 10 ) * PIXEL_SIZE, PIXEL_SIZE ) )


            # Make sure the enemy isn't attacking or dead
        if not EnemyAttacking and Enemy1.health > 0:
                # Draw the enemy's heath bar onto the screen
            pygame.draw.rect( DISPLAYSURF, ( 255, 0, 0 ), ( PIXEL_SIZE * 45, E_TurnBar.y - int ( PIXEL_SIZE * 1.5 ), int ( Enemy1.health / 10 ) * PIXEL_SIZE, PIXEL_SIZE ) )


            # Check if it is the player's turn but the player hasn't attacked yet
        if PlayerTurn and not PlayerAttacking:
            PrintMenu( CurrentMenu )    # Blit a popup menu onto the screen



            # Check if the enemy is dead
        if Enemy1.health <= 0 and Pause4Effect <= 0:

                # Check if the player has already recieved gold and xp for this battle
            if not CollectedLoot:
                Awards = PrintAwards( Enemy1 )
                P1.GainLoot( Awards[ 0 ], Awards[ 1 ] )

                CollectedLoot = True    # Make sure the player doesn't get extra awards
                Difficulty += 1         # Increase the game's difficulty slightly

            else:
                PrintAwards( Enemy1 )

        if P1.health <= 0:
            GameOver()



            # Render the mouse
        DISPLAYSURF.blit( MouseIMG, ( pygame.mouse.get_pos()[ 0 ], pygame.mouse.get_pos()[ 1 ], MOUSE_SIZE, MOUSE_SIZE ) )


            # Update the screen
        pygame.display.update()

            # Control framerate
        fpsClock.tick( FPS )

















            # Creates and prints out the map onto the screen, also reacts to stepping on certain tiles
def MainMap( P1 ):
    global Difficulty
    global FPS

        # Control FPS
    fpsClock = pygame.time.Clock()

        # Loads the music for the map
#    pygame.mixer.music.play()

        # Load movement Sound
    MoveSound = pygame.mixer.Sound( "sfx/zapsplat_impacts_stick_branch_large_drop_ground_25055.wav" )

        # Sets the writing at the top of the window
    pygame.display.set_caption( "< STORM THE CASTLE! >" )

        # Holds whether the three game winning items have been collected
    TorchCollected = False
    DivingGearCollected = False
    BatteringRamCollected = False

        # Create an array for the map's tiles
    Tiles = []

        # Constant for the size of the tiles
    TILE_SIZE = 30

        # Starting coordinates for tiles
    x = 0
    y = 0

        # Load the tiles according to Tutorial list
    for i in MAIN_MAP_1:

            # If the tile isn't a wall, create the tile to allow player passage
        if i != 3 and i != 6 and ( i < 9 or i > 11 ) and ( i < 18 or i > 21 ) and ( i < 23 or i > 26 ):
                # Add next tile
            Tiles.append( Tile( x, y, TILE_SIZE, TILE_SIZE, "Assets/Tiles/Main Tiles/Tile_" + str( i + 1 ) + ".png", False, False, False ) )

                # Correct X and Y positions for the next tile
            x += TILE_SIZE
            if x >= 100 * TILE_SIZE:
                x = 0
                y += TILE_SIZE

        elif i == 3:
                # Add next tile
            Tiles.append( Tile( x, y, TILE_SIZE, TILE_SIZE, "Assets/Tiles/Main Tiles/Tile_" + str( i + 1 ) + ".png", True, False, False, "Diving Gear" ) )

                # Correct X and Y positions for the next tile
            x += TILE_SIZE
            if x >= 100 * TILE_SIZE:
                x = 0
                y += TILE_SIZE

        elif i >= 9 and i <= 11:
                # Add next tile
            Tiles.append( Tile( x, y, TILE_SIZE, TILE_SIZE, "Assets/Tiles/Main Tiles/Tile_" + str( i + 1 ) + ".png", True, False, False, "Torch" ) )

                # Correct X and Y positions for the next tile
            x += TILE_SIZE
            if x >= 100 * TILE_SIZE:
                x = 0
                y += TILE_SIZE

        elif i >= 23 and i <= 25:
                # Add next tile
            Tiles.append( Tile( x, y, TILE_SIZE, TILE_SIZE, "Assets/Tiles/Main Tiles/Tile_" + str( i + 1 ) + ".png", True, False, False, "Battering Ram" ) )

                # Correct X and Y positions for the next tile
            x += TILE_SIZE
            if x >= 100 * TILE_SIZE:
                x = 0
                y += TILE_SIZE


            # If the tile is a wall, Set the tile to block the player
        else:
                # Add next tile
            Tiles.append( Tile( x, y, TILE_SIZE, TILE_SIZE, "Assets/Tiles/Main Tiles/Tile_" + str( i + 1 ) + ".png", True, False, False ) )

                # Correct X and Y positions for the next tile
            x += TILE_SIZE
            if x >= 100 * TILE_SIZE:
                x = 0
                y += TILE_SIZE



        # Variables for the camera
    CamX = 0
    CamY = 0

        # Set the player's starting position
    P1.SetPos( TILE_SIZE * 5, TILE_SIZE * 95 )

        # Holds the tile that the player is on
    TileOn = 5 + ( 95 * 100 )

        # Holds the chance for each event
    # Cursed, Witch, Item, Shop, Battle
    EventChance = [ 0, 0, 200, 150, 500 ]

        # Holds the position of the player before an event to make returning to the map easier
    P_x = 0
    P_y = 0





    while True:
            # Bool for events
        Moved = False

            # Handle events
        for event in pygame.event.get():
                # If the music has finished, play it again
            if event.type == SONG_FINISHED:
                pygame.mixer.music.play()

                # If the red X has been clicked, exit the program
            elif event.type == QUIT:

                pygame.quit()
                sys.exit()

                # Check for keypresses
            elif event.type == KEYDOWN:
                    # If the W key was pressed...
                if event.key == K_w or event.key == K_UP:
                    P1.y -= TILE_SIZE   # Move the player up 1 tile

                        # Correct player if they are offscreen
                    if P1.y < 0:
                        P1.y = 0
                    else:
                        TileOn -= 100   # Update the tile the player is on
                            # Check if the tile is a wall
                        if Tiles[ TileOn ].BlocksPlayer:
                                # Check if the Tile activated the bossfight ( Battering Ram required )
                            if Tiles[ TileOn ].GetItemReq( P1 ) == 0:
                                    # Exit the game and congradulate the player for winning
                                return CREDITS

                                # Check that the tile blockes the player ( Takes into account items )
                            elif Tiles[ TileOn ].GetItemReq( P1 ) == 3:
                                TileOn += 100   # Redo the player's tile change
                                P1.y += TILE_SIZE   # Move player back down

                                # Otherwise, the tile required an item to pass through it and the player owns the needed items
                                # e.g. Shallow water requires diving gear
                            else:
                                Moved = True
                        else:
                            Moved = True

                elif event.key == K_s or event.key == K_DOWN:
                    P1.y += TILE_SIZE
                        # Correct player if they are offscreen
                    if P1.y >= TILE_SIZE * 100:
                        P1.y = TILE_SIZE * 99
                    else:
                            # Update the tile the player is on
                        TileOn += 100
                        Tiles[ TileOn ].GetCollision( 0, 0, 0, 0, P1 )

                            # If the tile is a wall, move the player back
                        if Tiles[ TileOn ].BlocksPlayer:
                            if Tiles[ TileOn ].GetItemReq( P1 ) == 3:
                                    # Redo the player's tile change
                                TileOn -= 100
                                    # Move player back
                                P1.y -= TILE_SIZE

                            else:
                                Moved = True
                        else:
                            Moved = True

                elif event.key == K_a or event.key == K_LEFT:
                    P1.x -= TILE_SIZE
                        # Correct player if they are offscreen
                    if P1.x < 0:
                        P1.x = 0
                    else:
                            # Update the tile the player is on
                        TileOn -= 1

                            # If they stepped on the entrance to the cave
                        if P1.x == TILE_SIZE * 77 and P1.y >= TILE_SIZE * 97 and P1.y <= TILE_SIZE * 99 and "Torch" in P1.Items:

                            P1.SetPos( TILE_SIZE * 47, TILE_SIZE * 75 )
                            TileOn = 7547

                            # If the tile is a wall, move the player back
                        if Tiles[ TileOn ].BlocksPlayer:
                            if Tiles[ TileOn ].GetItemReq( P1 ) == 3:
                                    # Redo the player's tile change
                                TileOn += 1
                                    # Move player back
                                P1.x += TILE_SIZE
                            else:
                                Moved = True
                        else:
                            Moved = True

                elif event.key == K_d or event.key == K_RIGHT:
                    P1.x += TILE_SIZE
                        # Correct player if they are offscreen
                    if P1.x >= TILE_SIZE * 100:
                        P1.x = TILE_SIZE * 99
                    else:
                            # Update the tile the player is on
                        TileOn += 1

                            # If they stepped on the entrance to the cave
                        if P1.x == TILE_SIZE * 48 and P1.y >= TILE_SIZE * 74 and P1.y <= TILE_SIZE * 76 and "Torch" in P1.Items:
                            TileOn = 9878
                            P1.SetPos( TILE_SIZE * 78, TILE_SIZE * 98 )

                            # If the tile is a wall, move the player back
                        if Tiles[ TileOn ].BlocksPlayer:
                            if Tiles[ TileOn ].GetItemReq( P1 ) == 3:
                                    # Redo the player's tile change
                                TileOn -= 1
                                    # Move player back
                                P1.x -= TILE_SIZE
                            else:
                                Moved = True
                        else:
                            Moved = True





            # Check if an event has occured
        if Moved:
            P_x = P1.x
            P_y = P1.y

                # Check if a key place has been landed on
            if P1.x == TILE_SIZE * 9 and P1.y == TILE_SIZE * 27 and not TorchCollected:
                P1.health = P1.MAX_health
                ItemEvent( P1, 0, "Torch" )
                TorchCollected = True

            elif P1.x == TILE_SIZE * 48 and P1.y == TILE_SIZE * 9 and not DivingGearCollected:
                P1.health = P1.MAX_health
                ItemEvent( P1, 1, "Diving Gear" )
                DivingGearCollected = True

            elif P1.x == TILE_SIZE * 55 and P1.y == TILE_SIZE * 47 and not BatteringRamCollected:
                P1.health = P1.MAX_health
                ItemEvent( P1, 4, "Battering Ram" )

            else:

                EventCreated = random.randint( 0, 10000 )
                NumbersPassed = 0
                Event = 0
                for i in range( 0, len( EventChance ) ):
                    NumbersPassed += EventChance[ i ]
                    Event = 100
                    if EventCreated < NumbersPassed:
                        Event = i
                        break

                if Event == 0:
                    CursedEvent( P1 )

                elif Event == 1:
                    WitchEvent( P1 )

                elif Event == 2:
                    pygame.mixer.music.stop()
                    ItemEvent( P1, MAIN_MAP_1[ TileOn ] )
#                    pygame.mixer.music.load( "Music/wav/MapTrack.wav" )
#                    pygame.mixer.music.play()

                elif Event == 3:
                    pygame.mixer.music.stop()
                    ShopEvent( P1, MAIN_MAP_1[ TileOn ] )
#                    pygame.mixer.music.load( "Music/wav/MapTrack.wav" )
#                    pygame.mixer.music.play()

                elif Event == 4:
                    pygame.mixer.music.stop()
                    #BattleTransition()
                    BattleEvent( P1, MAIN_MAP_1[ TileOn ] )
#                    pygame.mixer.music.load( "Music/wav/MapTrack.wav" )
#                    pygame.mixer.music.play()

                else:
                    MoveSound.play()

            P1.x = P_x
            P1.y = P_y




            # Correct the camera
        CamX = P1.x - SCREEN_WIDTH / 2 + TILE_SIZE / 2
        if CamX < 0:
            CamX = 0
        elif CamX > TILE_SIZE * 100 - SCREEN_WIDTH:
            CamX = TILE_SIZE * 100 - SCREEN_WIDTH

        CamY = P1.y - SCREEN_HEIGHT / 2 + TILE_SIZE / 2
        if CamY < 0:
            CamY = 0
        elif CamY > TILE_SIZE * 100 - SCREEN_HEIGHT:
            CamY = TILE_SIZE * 100 - SCREEN_HEIGHT


                # Render everything
            # Render the tiles
        for i in Tiles:
            i.RenderCam( CamX, CamY )

            # Render the player
        P1.RenderMapCam( CamX, CamY )

            # Update the screen
        pygame.display.update()

            # Control framerate
        fpsClock.tick( FPS )


            # Thanks everyone who helped make this game
def Credits():
    global SONG_FINISHED

        # That hip music again :)
    pygame.mixer.music.stop()
    pygame.mixer.music.load( "Music/wav/MapTrack.wav" )
    pygame.mixer.music.play()

        # Load the background
    Background = pygame.image.load( "Assets/Backgrounds/Background_6.png" )
    Background = pygame.transform.scale( Background, ( SCREEN_WIDTH, SCREEN_HEIGHT ) )

        # All of the text that will be displayed during the credits
    Thanks = [
    [ "Developer", "Daniel Poole" ],            # Yay me !
    [ "Music", "Daniel Poole" ],
    [ "Play testers", "Cooper Larsen-Holm", "Mum + Dad", "Andre Hanna" ],
    [ "Resources", "Al Sweigart", "Sound effects - https://www.zapsplat.com" ],
    [ "Professional Advice", "Simon Livesy" ]
    ]

    Font = pygame.font.SysFont( "luxirb.ttf", 56 )  # Create the font that the credits will render in

        # Create a list of text ( images )
    TextSurf = [
    [],
    [],
    [],
    []
    ]

        # Iterate through the different jobs
    for i in range( 0, len ( Thanks ) - 1 ):
        TextSurf[ i ].append( Font.render( Thanks[ i ][ 0 ], False, ( 0, 0, 255 ) ) )
            # Iterate through the people that did the job
        for j in range( 1, len( Thanks[ i ] ) ):
            print( Thanks[ i ][ j ] )

                # Add the text the list of text
            TextSurf[ i ].append( Font.render( Thanks[ i ][ j ], False, ( 0, 0, 0 ) ) )

        # Holds the distance that the credits have scrolled
    Scroll = 0


        # Main credits loop
    while True:

            # Check for events
        for event in pygame.event.get():

                # If the song has ended, replay
            if event.type == SONG_FINISHED:
                pygame.mixer.music.play()

                # If the red X is clicked then exit the game
            elif event.type == QUIT:

                pygame.quit()
                sys.exit()

                # Check for keypresses
            elif event.type == KEYDOWN:
                    # If s is clicked then skip the credits
                if event.key == K_s:
                    return

                # Render everything
            # Render the background
        DISPLAYSURF.blit( Background, ( 0, 0 ) )

            # Render the text
        for i in range( 0, len ( TextSurf ) ):
            for j in range( 0, len( TextSurf[ i ] ) ):
                DISPLAYSURF.blit( TextSurf[ i ][ j ], ( ( i + 1 ) * SCREEN_WIDTH - Scroll, ( j + 1 ) * 100 ) )

            # Scroll the text across the screen
        Scroll += 2

            # If the credits have ended, return the the main menu
        if Scroll >= SCREEN_WIDTH * 4.5:
            return

            # Update the screen
        pygame.display.update()

















    # MAIN()
if __name__ == "__main__":

        # Initiate pygame
    pygame.init()

        # Create dev / debug stuff perposes / cheating :)
    #P1 = Player( "Default", 1, 1, 1, 1, 1, 1, 1, 1 )
    #P1.Gold = 10000
    #P1.speed = 50
    #P1.strength = 50
    #Difficulty = 10

    #P1.GainLoot( 0, 10 )

    #P1.Items.append( "Torch" )
    #MainMap( P1 )
    #ShopEvent( P1, 1 )
    #BossFight( P1 )
    #Credits()

        # Makes the mouse invisible so it can be replaced with my mouse :)
    pygame.mouse.set_visible( False )

        # Create a variable that holds what screen is on now
    Scene = MAIN_MENU
    #Scene = CREDITS

        # Main Game loop
    while True:

            # If the scene is the main menu, display the main menu and wait for actions
        if Scene == MAIN_MENU:
            Scene = MainMenu()

            # If the scene is the options menu, take in user imputs and adjust settings acordingly
        elif Scene == OPTIONS_MENU:
            P1 = Player( "Default", 1, 1, 1, 1, 1, 1, 1, 1 )
            P1.Gold = 10000
            P1.speed = 100
            P1.strength = 100
            P1.GainLoot( 0, 9 )

            Scene = MAIN_MAP

            # If the scene is the character creation menu, take in user imput to create the player's player
        elif Scene == CHARACTER_CREATION:

            PlayerStuff = CharacterCreation()   # Assign returned list to PlayerStuff

                # Create a new player depending on the list returned from CharacterCreation()
            P1 = Player( PlayerStuff[ 0 ], PlayerStuff[ 1 ], PlayerStuff[ 2 ], PlayerStuff[ 3 ], PlayerStuff[ 4 ], PlayerStuff[ 5 ], PlayerStuff[ 6 ], PlayerStuff[ 7 ], PlayerStuff[ 8 ] )

                # Set the difficulty depending on the list returned from CharacterCreation()
            Difficulty = PlayerStuff[ 9 ]

            #Scene = MAIN_MAP    # Tutorial skip :)
            Scene = TUTORIAL    # Set the scene to tutorial

            # If the scene is the Tutorial, play the tutorial
        elif Scene == TUTORIAL:
            Scene = Tutorial( P1 )

            # If the scene is the MAIN_MAP, start up the actual game ( BOSSFIGHT is in MainMap )
        elif Scene == MAIN_MAP:
            Scene == MainMap( P1 )
            Scene = CREDITS

        elif Scene == CREDITS:
            Credits()
            Scene = MAIN_MENU
